<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>横云断岭的专栏</title>
  <icon>https://www.gravatar.com/avatar/98cb0c8e8c8aac68e15d2a3145be3998</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hengyunabc.github.io/"/>
  <updated>2018-10-31T16:09:41.371Z</updated>
  <id>http://hengyunabc.github.io/</id>
  
  <author>
    <name>横云断岭/hengyunabc</name>
    <email>hengyunabc#gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入Spring Boot系列</title>
    <link href="http://hengyunabc.github.io/spring-boot-inside/"/>
    <id>http://hengyunabc.github.io/spring-boot-inside/</id>
    <published>2118-07-22T16:58:28.000Z</published>
    <updated>2018-10-31T16:09:41.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理-使用"><a href="#原理-使用" class="headerlink" title="原理/使用"></a>原理/使用</h2><ul><li><a href="/spring-boot-application-start-analysis">spring boot应用启动原理分析</a></li><li><a href="/spring-boot-executable-jar">spring boot executable jar/war 原理</a></li><li><a href="/spring-boot-classloader">深入Spring Boot：ClassLoader的继承关系和影响</a></li><li><a href="/spring-boot-context">深入Spring Boot：Spring Context的继承关系和影响</a></li><li><a href="/spring-boot-fat-jar-jsp-sample">深入Spring Boot：实现对Fat Jar jsp的支持</a></li><li><a href="/spring-boot-dubbo-hystrix/">深入Spring Boot：快速集成Dubbo + Hystrix</a></li><li><a href="/spring-scan-annotation/">正确实现用spring扫描自定义的annotation</a></li><li><a href="/spring-boot-starter-compatibility">深入Spring Boot：编写兼容Spring Boot1和Spring Boot2的Starter</a></li></ul><h2 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h2><ul><li><a href="/hibernate-validar-noclassdefounderror">深入JVM分析spring-boot应用hibernate-validator NoClassDefFoundError</a></li><li><a href="/spring-placeholder-inject-failed-cases">深入Spring Boot：那些注入不了的Spring占位符（${}表达式）</a></li><li><a href="/spring-boot-ArrayStoreException/">深入Spring Boot：怎样排查 java.lang.ArrayStoreException</a></li><li><a href="/spring-boot-database-type-none/">深入Spring Boot：排查 Cannot determine embedded database driver class for database type NONE</a></li><li><a href="/spring-boot-expected-single-but-found-2">深入Spring Boot：排查expected single matching bean but found 2的异常</a></li><li><a href="/spring-boot-transactional-nullpointerexception">深入Spring Boot：排查@Transactional引起的NullPointerException</a></li><li><a href="/spring-boot-enablewebmvc-static-404">深入Spring Boot：显式配置 @EnableWebMvc 导致静态资源访问失败</a></li><li><a href="/spring-boot-arthas-NoSuchMethodError">深入Spring Boot：利用Arthas排查NoSuchMethodError</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原理-使用&quot;&gt;&lt;a href=&quot;#原理-使用&quot; class=&quot;headerlink&quot; title=&quot;原理/使用&quot;&gt;&lt;/a&gt;原理/使用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/spring-boot-application-start-analysis&quot;&gt;sp
      
    
    </summary>
    
      <category term="技术" scheme="http://hengyunabc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://hengyunabc.github.io/tags/java/"/>
    
      <category term="spring" scheme="http://hengyunabc.github.io/tags/spring/"/>
    
      <category term="spring-boot" scheme="http://hengyunabc.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>Arthas实践--使用redefine排查应用奇怪的日志来源</title>
    <link href="http://hengyunabc.github.io/arthas-redefine-case/"/>
    <id>http://hengyunabc.github.io/arthas-redefine-case/</id>
    <published>2018-10-31T20:58:28.000Z</published>
    <updated>2018-10-31T16:09:41.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着应用越来越复杂，依赖越来越多，日志系统越来越混乱，有时会出现一些奇怪的日志，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] [] [] No credential found</span><br></pre></td></tr></table></figure><p>那么怎样排查这些奇怪的日志从哪里打印出来的呢？因为搞不清楚是什么logger打印出来的，所以想定位就比较头疼。</p><p>下面介绍用Alibaba开源的应用诊断利器Arthas的redefine命令快速定位奇怪日志来源。</p><ul><li>Arthas: <a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">https://github.com/alibaba/arthas</a></li><li>redefine命令：<a href="https://alibaba.github.io/arthas/redefine.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/redefine.html</a></li></ul><h2 id="修改StringBuilder"><a href="#修改StringBuilder" class="headerlink" title="修改StringBuilder"></a>修改StringBuilder</h2><p>首先在java代码里，字符串拼接基本都是通过<code>StringBuilder</code>来实现的。比如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hello</span><span class="params">(String world)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"hello "</span> + world;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上生成的字节码也是用<code>StringBuilder</code>来拼接的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.<span class="function">String <span class="title">hello</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">  descriptor: (Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">       0: new           #22                 // class java/lang/StringBuilder</span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       4: ldc           #24                 // String hello</span><br><span class="line">       6: invokespecial #26                 // Method java/lang/StringBuilder."&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">       <span class="number">9</span>: aload_0</span><br><span class="line">      10: invokevirtual #29                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      13: invokevirtual #33                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      <span class="number">16</span>: areturn</span><br></pre></td></tr></table></figure><p>在java的logger系统里，输出日志时通常也是<code>StringBuilder</code>来实现的，最终会调用<code>StringBuilder.toString()</code>，那么我们可以修改<code>StringBuilder</code>的代码来检测到日志来源。</p><p><code>StringBuilder.toString()</code> 的原生实现是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a copy, don't share the array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a copy, don't share the array</span></span><br><span class="line">String result = <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line"><span class="keyword">if</span>(result.contains(<span class="string">"No credential found"</span>)) &#123;</span><br><span class="line">System.err.println(result);</span><br><span class="line"><span class="keyword">new</span> Throwable().printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加的逻辑是：<strong>当String里包含<code>No credential found</code>时打印出当前栈，这样子就可以定位日志输出来源了。</strong></p><h2 id="编绎修改过的StringBuilder"><a href="#编绎修改过的StringBuilder" class="headerlink" title="编绎修改过的StringBuilder"></a>编绎修改过的StringBuilder</h2><p>其实很简单，在IDE里把<code>StringBuilder</code>的代码复制一份，然后贴到任意一个工程里，然后编绎即可。</p><p>也可以直接用javac来编绎：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac StringBuilder.java</span><br></pre></td></tr></table></figure><h2 id="启动应用，使用Arthas-redefine修改过的StringBuilder"><a href="#启动应用，使用Arthas-redefine修改过的StringBuilder" class="headerlink" title="启动应用，使用Arthas redefine修改过的StringBuilder"></a>启动应用，使用Arthas redefine修改过的StringBuilder</h2><p>启动应用后，在奇怪日志输出之前，先使用arthas attach应用，再redefine StringBuilder:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redefine -p /tmp/StringBuilder.class</span><br><span class="line">redefine success, size: 1</span><br></pre></td></tr></table></figure><p>当执行到输出<code>[] [] [] No credential found</code>的logger代码时，会打印当前栈。实际运行结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[] [] [] No credential found</span><br><span class="line">java.lang.Throwable</span><br><span class="line">at java.lang.StringBuilder.toString(StringBuilder.java:<span class="number">410</span>)</span><br><span class="line">at com.taobao.middleware.logger.util.MessageUtil.getMessage(MessageUtil.java:<span class="number">26</span>)</span><br><span class="line">at com.taobao.middleware.logger.util.MessageUtil.getMessage(MessageUtil.java:<span class="number">15</span>)</span><br><span class="line">at com.taobao.middleware.logger.slf4j.Slf4jLogger.info(Slf4jLogger.java:<span class="number">77</span>)</span><br><span class="line">at com.taobao.spas.sdk.common.log.SpasLogger.info(SpasLogger.java:<span class="number">18</span>)</span><br><span class="line">at com.taobao.spas.sdk.client.identity.CredentialWatcher.loadCredential(CredentialWatcher.java:<span class="number">128</span>)</span><br><span class="line">at com.taobao.spas.sdk.client.identity.CredentialWatcher.access$<span class="number">200</span>(CredentialWatcher.java:<span class="number">18</span>)</span><br><span class="line">at com.taobao.spas.sdk.client.identity.CredentialWatcher$<span class="number">1</span>.run(CredentialWatcher.java:<span class="number">58</span>)</span><br><span class="line">at java.util.TimerThread.mainLoop(Timer.java:<span class="number">555</span>)</span><br><span class="line">at java.util.TimerThread.run(Timer.java:<span class="number">505</span>)</span><br></pre></td></tr></table></figure><p><strong>可以看到是<code>spas.sdk</code>打印出了<code>[] [] [] No credential found</code>的日志。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>logger最终会用StringBuilder来输出</li><li>修改StringBuilder来定位输出特定日志的地方</li><li>使用Arthas redefine命令来加载修改过的StringBuilder</li><li>redefine命令实际上实现了任意代码线上debug的功能，可以随意本地修改代码重新编绎，然后线上redefine加载</li><li>redefine的功能过于强大，所以请小心使用:)</li></ul><h2 id="Arthas实践系列"><a href="#Arthas实践系列" class="headerlink" title="Arthas实践系列"></a>Arthas实践系列</h2><ul><li><a href="/arthas-logger-problem/">使用Arthas抽丝剥茧排查线上应用日志打满问题</a></li><li><a href="/spring-boot-arthas-NoSuchMethodError/">深入Spring Boot：利用Arthas排查NoSuchMethodError</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;随着应用越来越复杂，依赖越来越多，日志系统越来越混乱，有时会出现一些奇怪的日志，比如：&lt;/p&gt;
&lt;figure class=&quot;highlig
      
    
    </summary>
    
      <category term="技术" scheme="http://hengyunabc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://hengyunabc.github.io/tags/java/"/>
    
      <category term="logger" scheme="http://hengyunabc.github.io/tags/logger/"/>
    
      <category term="arthas" scheme="http://hengyunabc.github.io/tags/arthas/"/>
    
      <category term="redefine" scheme="http://hengyunabc.github.io/tags/redefine/"/>
    
  </entry>
  
  <entry>
    <title>Arthas实践--抽丝剥茧排查线上应用日志打满问题</title>
    <link href="http://hengyunabc.github.io/arthas-logger-problem/"/>
    <id>http://hengyunabc.github.io/arthas-logger-problem/</id>
    <published>2018-10-22T20:58:28.000Z</published>
    <updated>2018-10-31T16:09:41.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>在应用的 <code>service_stdout.log</code>里一直输出下面的日志，直接把磁盘打满了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">23:07:34.441 [TAIRCLIENT-1-thread-1] DEBUG io.netty.channel.nio.NioEventLoop - Selector.select() returned prematurely 14 times in a row.</span><br><span class="line">23:07:34.460 [TAIRCLIENT-1-thread-3] DEBUG io.netty.channel.nio.NioEventLoop - Selector.select() returned prematurely 3 times in a row.</span><br><span class="line">23:07:34.461 [TAIRCLIENT-1-thread-4] DEBUG io.netty.channel.nio.NioEventLoop - Selector.select() returned prematurely 3 times in a row.</span><br><span class="line">23:07:34.462 [TAIRCLIENT-1-thread-5] DEBUG io.netty.channel.nio.NioEventLoop - Selector.select() returned prematurely 3 times in a row.</span><br></pre></td></tr></table></figure><p> <code>service_stdout.log</code>是进程标准输出的重定向，可以初步判定是tair插件把日志输出到了stdout里。</p><p>尽管有了初步的判断，但是具体logger为什么会打到stdout里，还需要进一步排查，常见的方法可能是本地debug。</p><p>下面介绍利用arthas直接在线上定位问题的过程，主要使用<code>sc</code>和<code>getstatic</code>命令。</p><ul><li><a href="https://alibaba.github.io/arthas/sc.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/sc.html</a></li><li><a href="https://alibaba.github.io/arthas/getstatic.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/getstatic.html</a></li></ul><h2 id="定位logger的具体实现"><a href="#定位logger的具体实现" class="headerlink" title="定位logger的具体实现"></a>定位logger的具体实现</h2><p>日志是<code>io.netty.channel.nio.NioEventLoop</code>输出的，到netty的代码里查看，发现是DEBUG级别的输出：</p><ul><li><a href="https://github.com/netty/netty/blob/netty-4.0.35.Final/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java#L673" target="_blank" rel="noopener">https://github.com/netty/netty/blob/netty-4.0.35.Final/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java#L673</a></li></ul><p>然后用arthas的<code>sc</code>命令来查看具体的<code>io.netty.channel.nio.NioEventLoop</code>是从哪里加载的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>-<span class="title">info</span>        <span class="title">io</span>.<span class="title">netty</span>.<span class="title">channel</span>.<span class="title">nio</span>.<span class="title">NioEventLoop</span></span></span><br><span class="line"> code-source       file:/opt/app/plugins/tair-plugin/lib/netty-all-4.0.35.Final.jar!/</span><br><span class="line"> name              io.netty.channel.nio.NioEventLoop</span><br><span class="line"> isInterface       <span class="keyword">false</span></span><br><span class="line"> isAnnotation      <span class="keyword">false</span></span><br><span class="line"> isEnum            <span class="keyword">false</span></span><br><span class="line"> isAnonymousClass  <span class="keyword">false</span></span><br><span class="line"> isArray           <span class="keyword">false</span></span><br><span class="line"> isLocalClass      <span class="keyword">false</span></span><br><span class="line"> isMemberClass     <span class="keyword">false</span></span><br><span class="line"> isPrimitive       <span class="keyword">false</span></span><br><span class="line"> isSynthetic       <span class="keyword">false</span></span><br><span class="line"> simple-name       NioEventLoop</span><br><span class="line"> modifier          <span class="keyword">final</span>,<span class="keyword">public</span></span><br><span class="line"> annotation</span><br><span class="line"> interfaces</span><br><span class="line"> <span class="keyword">super</span>-<span class="class"><span class="keyword">class</span>       +-<span class="title">io</span>.<span class="title">netty</span>.<span class="title">channel</span>.<span class="title">SingleThreadEventLoop</span></span></span><br><span class="line"><span class="class">                     +-<span class="title">io</span>.<span class="title">netty</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">SingleThreadEventExecutor</span></span></span><br><span class="line"><span class="class">                       +-<span class="title">io</span>.<span class="title">netty</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">AbstractScheduledEventExecutor</span></span></span><br><span class="line"><span class="class">                         +-<span class="title">io</span>.<span class="title">netty</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">AbstractEventExecutor</span></span></span><br><span class="line"><span class="class">                           +-<span class="title">java</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">AbstractExecutorService</span></span></span><br><span class="line"><span class="class">                             +-<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span></span><br><span class="line"><span class="class"> <span class="title">class</span>-<span class="title">loader</span>      +-<span class="title">tair</span>-<span class="title">plugin</span>'<span class="title">s</span> <span class="title">ModuleClassLoader</span></span></span><br><span class="line"><span class="class"> <span class="title">classLoaderHash</span>   73<span class="title">ad2d6</span></span></span><br></pre></td></tr></table></figure><p>可见，的确是从tair插件里加载的。</p><p>查看NioEventLoop的代码，可以发现它有一个<code>logger</code>的field：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEventLoop</span> <span class="keyword">extends</span> <span class="title">SingleThreadEventLoop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InternalLogger logger = InternalLoggerFactory.getInstance(NioEventLoop.class);</span><br></pre></td></tr></table></figure><p>使用arthas的<code>getstatic</code>命令来查看这个<code>logger</code>具体实现类是什么（使用<code>-c</code>参数指定classloader）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ getstatic -c 73ad2d6 io.netty.channel.nio.NioEventLoop logger &apos;getClass().getName()&apos;</span><br><span class="line">field: logger</span><br><span class="line">@String[io.netty.util.internal.logging.Slf4JLogger]</span><br></pre></td></tr></table></figure><p>可以发现是<code>Slf4JLogger</code>。 </p><p>再查看io.netty.util.internal.logging.Slf4JLogger的实现，发现它内部有一个logger的field：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.util.internal.logging;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;a href="http://www.slf4j.org/"&gt;SLF4J&lt;/a&gt; logger.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slf4JLogger</span> <span class="keyword">extends</span> <span class="title">AbstractInternalLogger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">108038972685130825L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> Logger logger;</span><br></pre></td></tr></table></figure><p>那么使用arthas的<code>getstatic</code>命令来查看这个<code>logger</code>属性的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ getstatic -c <span class="number">73</span>ad2d6 io.netty.channel.nio.NioEventLoop logger <span class="string">'logger'</span></span><br><span class="line">field: logger</span><br><span class="line"><span class="meta">@Logger</span>[</span><br><span class="line">    serialVersionUID=<span class="meta">@Long</span>[<span class="number">5454405123156820674</span>],</span><br><span class="line">    FQCN=<span class="meta">@String</span>[ch.qos.logback.classic.Logger],</span><br><span class="line">    name=<span class="meta">@String</span>[io.netty.channel.nio.NioEventLoop],</span><br><span class="line">    level=<span class="keyword">null</span>,</span><br><span class="line">    effectiveLevelInt=<span class="meta">@Integer</span>[<span class="number">10000</span>],</span><br><span class="line">    parent=<span class="meta">@Logger</span>[Logger[io.netty.channel.nio]],</span><br><span class="line">    childrenList=<span class="keyword">null</span>,</span><br><span class="line">    aai=<span class="keyword">null</span>,</span><br><span class="line">    additive=<span class="meta">@Boolean</span>[<span class="keyword">true</span>],</span><br><span class="line">    loggerContext=<span class="meta">@LoggerContext</span>[ch.qos.logback.classic.LoggerContext[<span class="keyword">default</span>]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可见，logger的最本质实现类是：<code>ch.qos.logback.classic.Logger</code>。</p><p>再次用<code>getstatic</code>命令来确定jar包的location：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ getstatic -c <span class="number">73</span>ad2d6 io.netty.channel.nio.NioEventLoop logger <span class="string">'logger.getClass().getProtectionDomain().getCodeSource().getLocation()'</span></span><br><span class="line">field: logger</span><br><span class="line"><span class="meta">@URL</span>[</span><br><span class="line">    BUILTIN_HANDLERS_PREFIX=<span class="meta">@String</span>[sun.net.www.protocol],</span><br><span class="line">    serialVersionUID=<span class="meta">@Long</span>[-<span class="number">7627629688361524110</span>],</span><br><span class="line">    protocolPathProp=<span class="meta">@String</span>[java.protocol.handler.pkgs],</span><br><span class="line">    protocol=<span class="meta">@String</span>[jar],</span><br><span class="line">    host=<span class="meta">@String</span>[],</span><br><span class="line">    port=<span class="meta">@Integer</span>[-<span class="number">1</span>],</span><br><span class="line">    file=<span class="meta">@String</span>[file:/opt/app/plugins/tair-plugin/lib/logback-classic-<span class="number">1.2</span>.3.jar!/],</span><br><span class="line">    query=<span class="keyword">null</span>,</span><br><span class="line">    authority=<span class="meta">@String</span>[],</span><br><span class="line">    path=<span class="meta">@String</span>[file:/opt/app/plugins/tair-plugin/lib/logback-classic-<span class="number">1.2</span>.3.jar!/],</span><br><span class="line">    userInfo=<span class="keyword">null</span>,</span><br><span class="line">    ref=<span class="keyword">null</span>,</span><br><span class="line">    hostAddress=<span class="keyword">null</span>,</span><br><span class="line">    handler=<span class="meta">@Handler</span>[com.taobao.pandora.loader.jar.Handler@<span class="number">1</span>a0c361e],</span><br><span class="line">    hashCode=<span class="meta">@Integer</span>[<span class="number">126346621</span>],</span><br><span class="line">    tempState=<span class="keyword">null</span>,</span><br><span class="line">    factory=<span class="meta">@TomcatURLStreamHandlerFactory</span>[org.apache.catalina.webresources.TomcatURLStreamHandlerFactory@<span class="number">3</span>edd7b7],</span><br><span class="line">    handlers=<span class="meta">@Hashtable</span>[isEmpty=<span class="keyword">false</span>;size=<span class="number">4</span>],</span><br><span class="line">    streamHandlerLock=<span class="meta">@Object</span>[java.lang.Object@<span class="number">488</span>ccac9],</span><br><span class="line">    serialPersistentFields=<span class="meta">@ObjectStreamField</span>[][isEmpty=<span class="keyword">false</span>;size=<span class="number">7</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可见这个<code>ch.qos.logback.classic.Logger</code>的确是tair插件里加载的。</p><h2 id="定位logger的level"><a href="#定位logger的level" class="headerlink" title="定位logger的level"></a>定位logger的level</h2><p>上面已经定位logger的实现类是<code>ch.qos.logback.classic.Logger</code>，但是为什么它会输出<code>DEBUG</code> level的日志？</p><p>其实在上面的<code>getstatic -c 73ad2d6 io.netty.channel.nio.NioEventLoop logger &#39;logger&#39;</code>输出里，已经打印出它的level是null了。如果对logger有所了解的话，可以知道当child logger的level为null时，它的level取决于parent logger的level。</p><p>我们再来看下<code>ch.qos.logback.classic.Logger</code>的代码，它有一个parent logger的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">slf4j</span>.<span class="title">Logger</span>, <span class="title">LocationAwareLogger</span>, <span class="title">AppenderAttachable</span>&lt;<span class="title">ILoggingEvent</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The parent of this category. All categories have at least one ancestor</span></span><br><span class="line"><span class="comment">     * which is the root category.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">private</span> Logger parent;</span><br></pre></td></tr></table></figure><p>所以，我们可以通过<code>getstatic</code>来获取到这个parent属性的内容。然后通过多个parent操作，可以发现level都是null，最终发现ROOT level是DEBUG 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ getstatic -c <span class="number">73</span>ad2d6 io.netty.channel.nio.NioEventLoop logger <span class="string">'logger.parent.parent.parent.parent.parent'</span></span><br><span class="line">field: logger</span><br><span class="line"><span class="meta">@Logger</span>[</span><br><span class="line">    serialVersionUID=<span class="meta">@Long</span>[<span class="number">5454405123156820674</span>],</span><br><span class="line">    FQCN=<span class="meta">@String</span>[ch.qos.logback.classic.Logger],</span><br><span class="line">    name=<span class="meta">@String</span>[ROOT],</span><br><span class="line">    level=<span class="meta">@Level</span>[DEBUG],</span><br><span class="line">    effectiveLevelInt=<span class="meta">@Integer</span>[<span class="number">10000</span>],</span><br><span class="line">    parent=<span class="keyword">null</span>,</span><br><span class="line">    childrenList=<span class="meta">@CopyOnWriteArrayList</span>[isEmpty=<span class="keyword">false</span>;size=<span class="number">2</span>],</span><br><span class="line">    aai=<span class="meta">@AppenderAttachableImpl</span>[ch.qos.logback.core.spi.AppenderAttachableImpl@<span class="number">1</span>ecf9bae],</span><br><span class="line">    additive=<span class="meta">@Boolean</span>[<span class="keyword">true</span>],</span><br><span class="line">    loggerContext=<span class="meta">@LoggerContext</span>[ch.qos.logback.classic.LoggerContext[<span class="keyword">default</span>]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>所以 <code>io.netty.channel.nio.NioEventLoop</code>的logger的level取的是ROOT logger的配置，即默认值<code>DEBUG</code>。</p><p>具体实现可以查看<code>ch.qos.logback.classic.LoggerContext</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LoggerContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.loggerCache = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Logger&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loggerContextRemoteView = <span class="keyword">new</span> LoggerContextVO(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="keyword">new</span> Logger(Logger.ROOT_LOGGER_NAME, <span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.root.setLevel(Level.DEBUG);</span><br><span class="line">    loggerCache.put(Logger.ROOT_LOGGER_NAME, root);</span><br><span class="line">    initEvaluatorMap();</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.frameworkPackages = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么logback输出到了stdout里"><a href="#为什么logback输出到了stdout里" class="headerlink" title="为什么logback输出到了stdout里"></a>为什么logback输出到了stdout里</h2><p>上面我们得到结论</p><ul><li>tair插件里的logback默认的level是DEBUG，导致netty里的日志可以被打印出来</li></ul><p>那么我们可以猜测：</p><ul><li>tair里的logback没有特殊配置，或者只配置了tair自己的package，导致ROOT logger的日志直接输出到stdout里</li></ul><p>那么实现上tair里是使用了<code>logger-api</code>，它通过<code>LoggerFactory.getLogger</code>函数获取到了自己package的logger，然后设置level为<code>INFO</code>，并设置了appender。</p><p><strong>换而言之，tair插件里的logback没有设置ROOT logger，所以它的默认level是DEBUG，并且默认的appender会输出到stdout里。</strong></p><p>所以tair插件可以增加设置ROOT logger level为<code>INFO</code>来修复这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> com.taobao.middleware.logger.Logger logger</span><br><span class="line">= com.taobao.middleware.logger.LoggerFactory.getLogger(<span class="string">"com.taobao.tair"</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.taobao.middleware.logger.Logger infolog</span><br><span class="line">= com.taobao.middleware.logger.LoggerFactory.getLogger(<span class="string">"com.taobao.tair.custom-infolog"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> JM_LOG_RETAIN_COUNT = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String JM_LOG_FILE_SIZE = <span class="string">"200MB"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String tmp = System.getProperty(<span class="string">"JM.LOG.RETAIN.COUNT"</span>, <span class="string">"3"</span>);</span><br><span class="line">JM_LOG_RETAIN_COUNT = Integer.parseInt(tmp);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">JM_LOG_FILE_SIZE = System.getProperty(<span class="string">"JM.LOG.FILE.SIZE"</span>, <span class="string">"200MB"</span>);</span><br><span class="line"></span><br><span class="line">logger.setLevel(Level.INFO);</span><br><span class="line">logger.activateAppenderWithSizeRolling(<span class="string">"tair-client"</span>, <span class="string">"tair-client.log"</span>, <span class="string">"UTF-8"</span>,</span><br><span class="line">TairUtil.splitSize(JM_LOG_FILE_SIZE, <span class="number">0.8</span> / (JM_LOG_RETAIN_COUNT + <span class="number">1</span>)), JM_LOG_RETAIN_COUNT);</span><br><span class="line">logger.setAdditivity(<span class="keyword">false</span>);</span><br><span class="line">logger.activateAsync(<span class="number">500</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">"JM_LOG_RETAIN_COUNT "</span> + JM_LOG_RETAIN_COUNT + <span class="string">" JM_LOG_FILE_SIZE "</span> + JM_LOG_FILE_SIZE);</span><br><span class="line"></span><br><span class="line">infolog.setLevel(Level.INFO);</span><br><span class="line">infolog.activateAppenderWithSizeRolling(<span class="string">"tair-client"</span>, <span class="string">"tair-client-info.log"</span>, <span class="string">"UTF-8"</span>, <span class="string">"10MB"</span>, <span class="number">1</span>);</span><br><span class="line">infolog.setAdditivity(<span class="keyword">false</span>);</span><br><span class="line">infolog.activateAsync(<span class="number">500</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>tair插件里直接以api的方式设置了自己package下的logger</li><li>tair插件里netty的logger的packge和tair并不一样，所以它最终取的是ROOT logger的配置</li><li>logback默认的ROOT logger level是<code>DEBUG</code>，输出是stdout</li><li>利用arthas的<code>sc</code>命令定位具体的类</li><li>利用arthas的<code>getstatic</code>获取static filed的值</li><li>利用logger parent层联的特性，可以向上一层层获取到ROOT logger的配置</li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul><li>Arthas开源：<a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">https://github.com/alibaba/arthas</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h2&gt;&lt;p&gt;在应用的 &lt;code&gt;service_stdout.log&lt;/code&gt;里一直输出下面的日志，直接把磁盘打满了：&lt;/p&gt;
&lt;figure c
      
    
    </summary>
    
      <category term="技术" scheme="http://hengyunabc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://hengyunabc.github.io/tags/java/"/>
    
      <category term="logger" scheme="http://hengyunabc.github.io/tags/logger/"/>
    
      <category term="classloader" scheme="http://hengyunabc.github.io/tags/classloader/"/>
    
      <category term="arthas" scheme="http://hengyunabc.github.io/tags/arthas/"/>
    
  </entry>
  
  <entry>
    <title>深入Spring Boot：利用Arthas排查NoSuchMethodError</title>
    <link href="http://hengyunabc.github.io/spring-boot-arthas-NoSuchMethodError/"/>
    <id>http://hengyunabc.github.io/spring-boot-arthas-NoSuchMethodError/</id>
    <published>2018-09-25T20:58:28.000Z</published>
    <updated>2018-10-31T16:09:41.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有时spring boot应用会遇到<code>java.lang.NoSuchMethodError</code>的问题，下面以具体的demo来说明怎样利用<a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">arthas</a>来排查。</p><p>Demo: <a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-NoSuchMethodError" target="_blank" rel="noopener">https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-NoSuchMethodError</a></p><h2 id="在应用的main函数里catch住异常，保证进程不退出"><a href="#在应用的main函数里catch住异常，保证进程不退出" class="headerlink" title="在应用的main函数里catch住异常，保证进程不退出"></a>在应用的main函数里catch住异常，保证进程不退出</h2><p>很多时候当应用抛出异常后，进程退出了，就比较难排查问题。可以先改下main函数，把异常catch住：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">SpringApplication.run(DemoNoSuchMethodErrorApplication.class, args);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// block</span></span><br><span class="line">System.in.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo启动之后，抛出的异常是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NoSuchMethodError: org.springframework.core.annotation.AnnotationAwareOrderComparator.sort(Ljava/util/List;)V</span><br><span class="line">at org.springframework.boot.SpringApplication.getSpringFactoriesInstances(SpringApplication.java:<span class="number">394</span>)</span><br><span class="line">at org.springframework.boot.SpringApplication.getSpringFactoriesInstances(SpringApplication.java:<span class="number">383</span>)</span><br><span class="line">at org.springframework.boot.SpringApplication.initialize(SpringApplication.java:<span class="number">249</span>)</span><br><span class="line">at org.springframework.boot.SpringApplication.&lt;init&gt;(SpringApplication.java:<span class="number">225</span>)</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:<span class="number">1118</span>)</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:<span class="number">1107</span>)</span><br><span class="line">at com.example.demoNoSuchMethodError.DemoNoSuchMethodErrorApplication.main(DemoNoSuchMethodErrorApplication.java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure><p>显然，异常的意思是<code>AnnotationAwareOrderComparator</code>缺少<code>sort(Ljava/util/List;)V</code>这个函数。</p><h2 id="安装arthas"><a href="#安装arthas" class="headerlink" title="安装arthas"></a>安装arthas</h2><p>参考：<a href="https://alibaba.github.io/arthas/install-detail.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/install-detail.html</a></p><h2 id="使用sc命令查找类所在的jar包"><a href="#使用sc命令查找类所在的jar包" class="headerlink" title="使用sc命令查找类所在的jar包"></a>使用sc命令查找类所在的jar包</h2><p>应用需要抛出了异常，但是进程还没有退出，我们用arthas来attach上去。比如在mac下面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./as.sh</span><br></pre></td></tr></table></figure><p>然后选择<code>com.example.demoNoSuchMethodError.DemoNoSuchMethodErrorApplication</code>进程。</p><p>再执行<a href="https://alibaba.github.io/arthas/sc.html" target="_blank" rel="noopener">sc</a>命令来查找类：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ sc -d org.springframework.core.annotation.AnnotationAwareOrderComparator</span><br><span class="line"> <span class="class"><span class="keyword">class</span>-<span class="title">info</span>        <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">core</span>.<span class="title">annotation</span>.<span class="title">AnnotationAwareOrderComparator</span></span></span><br><span class="line"><span class="class"> <span class="title">code</span>-<span class="title">source</span>       /<span class="title">Users</span>/<span class="title">hengyunabc</span>/.<span class="title">m2</span>/<span class="title">repository</span>/<span class="title">org</span>/<span class="title">springframework</span>/<span class="title">spring</span>/2.5.6.<span class="title">SEC03</span>/<span class="title">spring</span>-2.5.6.<span class="title">SEC03</span>.<span class="title">jar</span></span></span><br><span class="line"><span class="class"> <span class="title">name</span>              <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">core</span>.<span class="title">annotation</span>.<span class="title">AnnotationAwareOrderComparator</span></span></span><br><span class="line"><span class="class"> <span class="title">isInterface</span>       <span class="title">false</span></span></span><br><span class="line"><span class="class"> <span class="title">isAnnotation</span>      <span class="title">false</span></span></span><br><span class="line"><span class="class"> <span class="title">isEnum</span>            <span class="title">false</span></span></span><br><span class="line"><span class="class"> <span class="title">isAnonymousClass</span>  <span class="title">false</span></span></span><br><span class="line"><span class="class"> <span class="title">isArray</span>           <span class="title">false</span></span></span><br><span class="line"><span class="class"> <span class="title">isLocalClass</span>      <span class="title">false</span></span></span><br><span class="line"><span class="class"> <span class="title">isMemberClass</span>     <span class="title">false</span></span></span><br><span class="line"><span class="class"> <span class="title">isPrimitive</span>       <span class="title">false</span></span></span><br><span class="line"><span class="class"> <span class="title">isSynthetic</span>       <span class="title">false</span></span></span><br><span class="line"><span class="class"> <span class="title">simple</span>-<span class="title">name</span>       <span class="title">AnnotationAwareOrderComparator</span></span></span><br><span class="line"><span class="class"> <span class="title">modifier</span>          <span class="title">public</span></span></span><br><span class="line"><span class="class"> <span class="title">annotation</span></span></span><br><span class="line"><span class="class"> <span class="title">interfaces</span></span></span><br><span class="line"><span class="class"> <span class="title">super</span>-<span class="title">class</span>       +-<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">core</span>.<span class="title">OrderComparator</span></span></span><br><span class="line"><span class="class">                     +-<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span></span><br><span class="line"><span class="class"> <span class="title">class</span>-<span class="title">loader</span>      +-<span class="title">sun</span>.<span class="title">misc</span>.<span class="title">Launcher</span>$<span class="title">AppClassLoader</span>@5<span class="title">c647e05</span></span></span><br><span class="line"><span class="class">                     +-<span class="title">sun</span>.<span class="title">misc</span>.<span class="title">Launcher</span>$<span class="title">ExtClassLoader</span>@689<span class="title">e3d07</span></span></span><br><span class="line"><span class="class"> <span class="title">classLoaderHash</span>   5<span class="title">c647e05</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line">Affect(row-cnt:1) cost in 41 ms.</span><br></pre></td></tr></table></figure><p>可以看到<code>AnnotationAwareOrderComparator</code>是从<code>spring-2.5.6.SEC03.jar</code>里加载的。</p><h2 id="使用jad查看反编绎的源代码"><a href="#使用jad查看反编绎的源代码" class="headerlink" title="使用jad查看反编绎的源代码"></a>使用jad查看反编绎的源代码</h2><p>下面使用<a href="https://alibaba.github.io/arthas/jad.html" target="_blank" rel="noopener">jad</a>命令来查看<code>AnnotationAwareOrderComparator</code>的源代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$ jad org.springframework.core.annotation.AnnotationAwareOrderComparator</span><br><span class="line"></span><br><span class="line">ClassLoader:</span><br><span class="line">+-sun.misc.Launcher$AppClassLoader@5c647e05</span><br><span class="line">  +-sun.misc.Launcher$ExtClassLoader@689e3d07</span><br><span class="line"></span><br><span class="line">Location:</span><br><span class="line">/Users/hengyunabc/.m2/repository/org/springframework/spring/2.5.6.SEC03/spring-2.5.6.SEC03.jar</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Decompiled with CFR 0_132.</span><br><span class="line"> */</span><br><span class="line">package org.springframework.core.annotation;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.Annotation;</span><br><span class="line">import org.springframework.core.OrderComparator;</span><br><span class="line">import org.springframework.core.Ordered;</span><br><span class="line">import org.springframework.core.annotation.Order;</span><br><span class="line"></span><br><span class="line">public class AnnotationAwareOrderComparator</span><br><span class="line">extends OrderComparator &#123;</span><br><span class="line">    protected int getOrder(Object obj) &#123;</span><br><span class="line">        Order order;</span><br><span class="line">        if (obj instanceof Ordered) &#123;</span><br><span class="line">            return ((Ordered)obj).getOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        if (obj != null &amp;&amp; (order = obj.getClass().getAnnotation(Order.class)) != null) &#123;</span><br><span class="line">            return order.value();</span><br><span class="line">        &#125;</span><br><span class="line">        return Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Affect(row-cnt:1) cost in 286 ms.</span><br></pre></td></tr></table></figure><p>可见，<code>AnnotationAwareOrderComparator</code>的确没有<code>sort(Ljava/util/List;)V</code>函数。</p><h2 id="排掉依赖，解决问题"><a href="#排掉依赖，解决问题" class="headerlink" title="排掉依赖，解决问题"></a>排掉依赖，解决问题</h2><p>从上面的排查里，可以确定</p><ul><li><code>AnnotationAwareOrderComparator</code>来自<code>spring-2.5.6.SEC03.jar</code>，的确没有<code>sort(Ljava/util/List;)V</code>函数。</li></ul><p>所以，可以检查maven依赖，把spring 2的jar包排掉，这样子就可以解决问题了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>仔细看<code>NoSuchMethodError</code>的异常信息，了解是什么类缺少了什么函数</li><li>利用arthas来查找类，反编绎源码，确认问题</li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul><li><a href="https://alibaba.github.io/arthas" target="_blank" rel="noopener">Arthas–Alibaba开源Java诊断利器</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有时spring boot应用会遇到&lt;code&gt;java.lang.NoSuchMethodError&lt;/code&gt;的问题，下面以具体的de
      
    
    </summary>
    
      <category term="技术" scheme="http://hengyunabc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://hengyunabc.github.io/tags/java/"/>
    
      <category term="arthas" scheme="http://hengyunabc.github.io/tags/arthas/"/>
    
      <category term="spring" scheme="http://hengyunabc.github.io/tags/spring/"/>
    
      <category term="spring-boot" scheme="http://hengyunabc.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>深入Spring Boot：显式配置 @EnableWebMvc 导致静态资源访问失败</title>
    <link href="http://hengyunabc.github.io/spring-boot-enablewebmvc-static-404/"/>
    <id>http://hengyunabc.github.io/spring-boot-enablewebmvc-static-404/</id>
    <published>2018-08-08T20:19:38.000Z</published>
    <updated>2018-10-31T16:09:41.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>当用户在自己的spring boot main class上面显式使用了<code>@EnableWebMvc</code>，发现原来的放在 <code>src/main/resources/static</code> 目录下面的静态资源访问不到了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如在用户代码目录<code>src/main/resources</code>里有一个<code>hello.txt</code>的资源。访问 <code>http://localhost:8080/hello.txt</code> 返回的结果是404：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Whitelabel Error Page</span><br><span class="line"></span><br><span class="line">This application has no explicit mapping for /error, so you are seeing this as a fallback.</span><br><span class="line"></span><br><span class="line">Thu Jun 01 11:39:41 CST 2017</span><br><span class="line">There was an unexpected error (type=Not Found, status=404).</span><br><span class="line">No message available</span><br></pre></td></tr></table></figure><h2 id="静态资源访问失败原因"><a href="#静态资源访问失败原因" class="headerlink" title="静态资源访问失败原因"></a>静态资源访问失败原因</h2><h3 id="EnableWebMvc的实现"><a href="#EnableWebMvc的实现" class="headerlink" title="@EnableWebMvc的实现"></a><code>@EnableWebMvc</code>的实现</h3><p>那么为什么用户显式配置了<code>@EnableWebMvc</code>，spring boot访问静态资源会失败？</p><p>我们先来看下<code>@EnableWebMvc</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(DelegatingWebMvcConfiguration.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebMvc &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A subclass of &#123;<span class="doctag">@code</span> WebMvcConfigurationSupport&#125; that detects and delegates</span></span><br><span class="line"><span class="comment"> * to all beans of type &#123;<span class="doctag">@link</span> WebMvcConfigurer&#125; allowing them to customize the</span></span><br><span class="line"><span class="comment"> * configuration provided by &#123;<span class="doctag">@code</span> WebMvcConfigurationSupport&#125;. This is the</span></span><br><span class="line"><span class="comment"> * class actually imported by &#123;<span class="doctag">@link</span> EnableWebMvc <span class="doctag">@EnableWebMvc</span>&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rossen Stoyanchev</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>可以看到<code>@EnableWebMvc</code> 引入了 <code>WebMvcConfigurationSupport</code>，是spring mvc 3.1里引入的一个自动初始化配置的<code>@Configuration</code> 类。</p><h3 id="spring-boot里的静态资源访问的实现"><a href="#spring-boot里的静态资源访问的实现" class="headerlink" title="spring boot里的静态资源访问的实现"></a>spring boot里的静态资源访问的实现</h3><p>再来看下spring boot里是怎么实现对<code>src/main/resources/static</code>这些目录的支持。</p><p>主要是通过<code>org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration</code>来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet.class, DispatcherServlet.class,</span><br><span class="line">WebMvcConfigurerAdapter.class &#125;)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(WebMvcConfigurationSupport.class)</span><br><span class="line"><span class="meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE + <span class="number">10</span>)</span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(&#123; DispatcherServletAutoConfiguration.class,</span><br><span class="line">ValidationAutoConfiguration.class &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>可以看到 <code>@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</code> ，这个条件导致spring boot的<code>WebMvcAutoConfiguration</code>不生效。</p><p>总结下具体的原因：</p><ol start="0"><li>用户配置了<code>@EnableWebMvc</code></li><li>Spring扫描所有的注解，再从注解上扫描到<code>@Import</code>，把这些<code>@Import</code>引入的bean信息都缓存起来</li><li>在扫描到<code>@EnableWebMvc</code>时，通过<code>@Import</code>加入了 <code>DelegatingWebMvcConfiguration</code>，也就是<code>WebMvcConfigurationSupport</code></li><li>spring再处理<code>@Conditional</code>相关的注解，判断发现已有<code>WebMvcConfigurationSupport</code>，就跳过了spring bootr的<code>WebMvcAutoConfiguration</code></li></ol><p>所以spring boot自己的静态资源配置不生效。</p><p>其实在spring boot的文档里也有提到这点： <a href="http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration" target="_blank" rel="noopener">http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration</a></p><ul><li>If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components.</li></ul><h3 id="Spring-Boot-ResourceProperties的配置"><a href="#Spring-Boot-ResourceProperties的配置" class="headerlink" title="Spring Boot ResourceProperties的配置"></a>Spring Boot ResourceProperties的配置</h3><p>在spring boot里静态资源目录的配置是在<code>ResourceProperties</code>里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.resources"</span>, ignoreUnknownFields = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceProperties</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] SERVLET_RESOURCE_LOCATIONS = &#123; <span class="string">"/"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123;</span><br><span class="line"><span class="string">"classpath:/META-INF/resources/"</span>, <span class="string">"classpath:/resources/"</span>,</span><br><span class="line"><span class="string">"classpath:/static/"</span>, <span class="string">"classpath:/public/"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] RESOURCE_LOCATIONS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">RESOURCE_LOCATIONS = <span class="keyword">new</span> String[CLASSPATH_RESOURCE_LOCATIONS.length</span><br><span class="line">+ SERVLET_RESOURCE_LOCATIONS.length];</span><br><span class="line">System.arraycopy(SERVLET_RESOURCE_LOCATIONS, <span class="number">0</span>, RESOURCE_LOCATIONS, <span class="number">0</span>,</span><br><span class="line">SERVLET_RESOURCE_LOCATIONS.length);</span><br><span class="line">System.arraycopy(CLASSPATH_RESOURCE_LOCATIONS, <span class="number">0</span>, RESOURCE_LOCATIONS,</span><br><span class="line">SERVLET_RESOURCE_LOCATIONS.length, CLASSPATH_RESOURCE_LOCATIONS.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>WebMvcAutoConfigurationAdapter</code>里会初始始化相关的ResourceHandler。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration.WebMvcAutoConfigurationAdapter</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123; EnableWebMvcConfiguration.class, MvcValidatorRegistrar.class &#125;)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123; WebMvcProperties.class, ResourceProperties.class &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcAutoConfigurationAdapter</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory</span><br><span class="line">      .getLog(WebMvcConfigurerAdapter.class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ResourceProperties resourceProperties;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Default resource handling disabled"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Integer cachePeriod = <span class="keyword">this</span>.resourceProperties.getCachePeriod();</span><br><span class="line">    <span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">"/webjars/**"</span>)) &#123;</span><br><span class="line">      customizeResourceHandlerRegistration(</span><br><span class="line">          registry.addResourceHandler(<span class="string">"/webjars/**"</span>)</span><br><span class="line">              .addResourceLocations(</span><br><span class="line">                  <span class="string">"classpath:/META-INF/resources/webjars/"</span>)</span><br><span class="line">          .setCachePeriod(cachePeriod));</span><br><span class="line">    &#125;</span><br><span class="line">    String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">    <span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">      customizeResourceHandlerRegistration(</span><br><span class="line">          registry.addResourceHandler(staticPathPattern)</span><br><span class="line">              .addResourceLocations(</span><br><span class="line">                  <span class="keyword">this</span>.resourceProperties.getStaticLocations())</span><br><span class="line">          .setCachePeriod(cachePeriod));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>用户可以自己修改这个默认的静态资源目录，但是不建议，因为很容易引出奇怪的404问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h2&gt;&lt;p&gt;当用户在自己的spring boot main class上面显式使用了&lt;code&gt;@EnableWebMvc&lt;/code&gt;，发现原来的放在
      
    
    </summary>
    
      <category term="技术" scheme="http://hengyunabc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="spring" scheme="http://hengyunabc.github.io/tags/spring/"/>
    
      <category term="spring-boot" scheme="http://hengyunabc.github.io/tags/spring-boot/"/>
    
      <category term="web" scheme="http://hengyunabc.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>深入Spring Boot：编写兼容Spring Boot1和Spring Boot2的Starter</title>
    <link href="http://hengyunabc.github.io/spring-boot-starter-compatibility/"/>
    <id>http://hengyunabc.github.io/spring-boot-starter-compatibility/</id>
    <published>2018-07-25T19:58:28.000Z</published>
    <updated>2018-10-31T16:09:41.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Spring Boot 2正式发布已经有段时间，应用升级之前，starter先要升级，那么如何支持Spring Boot 2？</p><h2 id="为什么选择starter同时兼容spring-boot-1和spring-boot-2"><a href="#为什么选择starter同时兼容spring-boot-1和spring-boot-2" class="headerlink" title="为什么选择starter同时兼容spring boot 1和spring boot 2"></a>为什么选择starter同时兼容spring boot 1和spring boot 2</h2><ul><li><p>从用户角度来看</p><p>  如果不在一个starter里兼容，比如用版本号来区分，spring boot 1的用户使用<code>1.*</code>，spring boot 2用户使用<code>2.*</code>，这样用户升级会有很大困扰。</p><p>  另外，我们的starter是以日期为版本号的，如果再分化，则就会出现<code>2018-06-stable-boot1</code>，<code>2018-06-stable-boot2</code>，这样子很丑陋。</p></li><li><p>从开发者角度来看</p><p>  要同时维护两个分支，修改代码时要合到两个分支上，发版本时要同时两个。如果有统一的bom文件，也需要维护两份。工作量翻倍，而且很容易出错。</p></li></ul><p>因此，我们决定在同一个代码分支里，同时支持spring boot 1/2。减少开发维护成本，减少用户使用困扰。</p><h2 id="编写兼容的starter的难点"><a href="#编写兼容的starter的难点" class="headerlink" title="编写兼容的starter的难点"></a>编写兼容的starter的难点</h2><p>spring boot starter的代码入口都是在各种<code>@Configuration</code>类里，这为我们编写兼容starter提供了条件。</p><p>但还是有一些难点：</p><ul><li>某些类不兼容，比如在spring boot 2里删除掉了</li><li>代码模块，maven依赖怎样组织</li><li>怎样保证starter在spring boot 1/2里都能正常工作</li></ul><h2 id="通过ASM分析现有的starter里不兼容的类"><a href="#通过ASM分析现有的starter里不兼容的类" class="headerlink" title="通过ASM分析现有的starter里不兼容的类"></a>通过ASM分析现有的starter里不兼容的类</h2><ul><li><a href="https://github.com/hengyunabc/springboot-classchecker" target="_blank" rel="noopener">https://github.com/hengyunabc/springboot-classchecker</a></li></ul><p>springboot-classchecker可以从jar包里扫描出哪些类在spring boot 2里不存在的。</p><blockquote><p>工作原理：springboot-classchecker自身在pom.xml里依赖的是spring boot 2，扫描jar包里通过ASM分析到所有的String，提取出类名之后，再尝试在ClassLoader里加载，如果加载不到，则说明这个类在spring boot 2里不存在。</p></blockquote><p>例如扫描<code>demo-springboot1-starter.jar</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package</span><br><span class="line">java -jar target/classchecker-0.0.1-SNAPSHOT.jar demo-springboot1-starter.jar</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">path: demo-springboot1-starter.jar</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.ConditionalOnEnabledHealthIndicator</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.EndpointAutoConfiguration</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.HealthIndicatorAutoConfiguration</span><br></pre></td></tr></table></figure><p>那么这些类在spring boot 2在哪里了？</p><p>实际上是改了package：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.actuate.autoconfigure.health.ConditionalOnEnabledHealthIndicator</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.endpoint.EndpointAutoConfiguration</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.health.HealthIndicatorAutoConfiguration</span><br></pre></td></tr></table></figure><p>通过扫描20多个starter jar包，发现不兼容的类有：</p><ul><li>org.springframework.boot.env.PropertySourcesLoader</li><li>org.springframework.boot.autoconfigure.jdbc.DataSourceBuilder</li><li>org.springframework.boot.bind.RelaxedDataBinder</li><li>Endpoint/HealthIndicator 相关的类</li></ul><p>可以总结：</p><ul><li>spring boot核心的类，autoconfigure相关的没有改动</li><li>大部分修改的是Endpoint/HealthIndicator 相关的类</li></ul><h2 id="spring-boot-utils兼容工具类"><a href="#spring-boot-utils兼容工具类" class="headerlink" title="spring-boot-utils兼容工具类"></a>spring-boot-utils兼容工具类</h2><ul><li><a href="https://github.com/hengyunabc/spring-boot-utils" target="_blank" rel="noopener">https://github.com/hengyunabc/spring-boot-utils</a></li></ul><p>spring-boot-utils提供兼容工具类，同时支持spring boot 1/2。</p><h3 id="BinderUtils"><a href="#BinderUtils" class="headerlink" title="BinderUtils"></a>BinderUtils</h3><p>在spring boot 1里，注入环境变量有时需要用到<code>RelaxedDataBinder</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyProperties myProperties = <span class="keyword">new</span> MyProperties();</span><br><span class="line">MutablePropertySources propertySources = environment.getPropertySources();</span><br><span class="line"><span class="keyword">new</span> RelaxedDataBinder(myProperties, <span class="string">"spring.my"</span>).bind(<span class="keyword">new</span> PropertySourcesPropertyValues(propertySources));</span><br></pre></td></tr></table></figure><p>在spring boot 2里，<code>RelaxedDataBinder</code>删除掉了，新的写法是用<code>Binder</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Binder binder = Binder.get(environment);</span><br><span class="line">MyProperties myProperties = binder.bind(<span class="string">"spring.my"</span>, MyProperties.class).get();</span><br></pre></td></tr></table></figure><p>通过BinderUtils，则可以同时支持spring boot1/2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyProperties myProperties = BinderUtils.bind(environment, <span class="string">"spring.my"</span>, MyProperties.class);</span><br></pre></td></tr></table></figure><h3 id="ConditionalOnSpringBoot1-ConditionalOnSpringBoot2"><a href="#ConditionalOnSpringBoot1-ConditionalOnSpringBoot2" class="headerlink" title="@ConditionalOnSpringBoot1/@ConditionalOnSpringBoot2"></a>@ConditionalOnSpringBoot1/@ConditionalOnSpringBoot2</h3><p>spring boot starter的功能大部分都是通过<code>@Configuration</code>组装起来的。spring boot 1的Configuration类，不能在spring boot 2里启用。则可以通过<code>@ConditionalOnSpringBoot1</code>，<code>@ConditionalOnSpringBoot2</code>这两个注解来分别支持。</p><p>其实原理很简单，判断spring boot 1/2里各自有的存在的类就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass</span>(name = <span class="string">"org.springframework.boot.bind.RelaxedDataBinder"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnSpringBoot1 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass</span>(name = <span class="string">"org.springframework.boot.context.properties.bind.Binder"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnSpringBoot2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Starter代码模块组织"><a href="#Starter代码模块组织" class="headerlink" title="Starter代码模块组织"></a>Starter代码模块组织</h2><p>下面以实际的一个starter来说明。</p><ul><li><a href="https://github.com/hengyunabc/endpoints-spring-boot-starter" target="_blank" rel="noopener">https://github.com/hengyunabc/endpoints-spring-boot-starter</a></li></ul><blockquote><p>spring boot web应用的mappings信息，可以在<code>/mappings</code> endpoint查询到。但是这么多endpoint，它们都提供了哪些url？</p></blockquote><blockquote><p>endpoints-spring-boot-starter的功能是展示所有endpoints的url mappings信息</p></blockquote><p><code>endpoints-spring-boot-starter</code>里需要给spring boot 1/2同时提供endpoint功能，代码模块如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">endpoints-spring-boot-starter</span><br><span class="line">|__ endpoints-spring-boot-autoconfigure1</span><br><span class="line">|__ endpoints-spring-boot-autoconfigure2</span><br></pre></td></tr></table></figure><ul><li>endpoints-spring-boot-autoconfigure1模块在pom.xml里依赖的是spring boot 1相关的jar，并且都设置为<code>&lt;optional&gt;true&lt;/optional&gt;</code></li><li>endpoints-spring-boot-autoconfigure2的配置类似</li><li>endpoints-spring-boot-starter依赖autoconfigure1 和 autoconfigure2</li><li>如果有公共的逻辑，可以增加一个commons模块</li></ul><h3 id="Endpoint兼容"><a href="#Endpoint兼容" class="headerlink" title="Endpoint兼容"></a>Endpoint兼容</h3><p>以 endpoints-spring-boot-autoconfigure1模块为例说明怎样处理。</p><ul><li><p><code>EndPointsEndPoint</code>类继承自spring boot 1的<code>AbstractMvcEndpoint</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"endpoints.endpoints"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EndPointsEndPoint</span> <span class="keyword">extends</span> <span class="title">AbstractMvcEndpoint</span> </span>&#123;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>@ManagementContextConfiguration</code>引入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ManagementContextConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EndPointsEndPointManagementContextConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnEnabledEndpoint</span>(<span class="string">"endpoints"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> EndPointsEndPoint <span class="title">EndPointsEndPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EndPointsEndPoint endPointsEndPoint = <span class="keyword">new</span> EndPointsEndPoint();</span><br><span class="line">        <span class="keyword">return</span> endPointsEndPoint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>META-INF/resources/spring.factories</code>里配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.actuate.autoconfigure.ManagementContextConfiguration=\</span><br><span class="line">io.github.hengyunabc.endpoints.autoconfigure1.EndPointsEndPointManagementContextConfiguration</span><br></pre></td></tr></table></figure></li></ul><p>因为<code>org.springframework.boot.actuate.autoconfigure.ManagementContextConfiguration</code>是只在spring boot 1里，在spring boot 2的应用里不会加载它，所以autoconfigure1模块天然兼容spring boot 2。</p><p>那么类似的，autoconfigure2模块里在<code>META-INF/resources/spring.factories</code>配置的是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.actuate.autoconfigure.web.ManagementContextConfiguration=\</span><br><span class="line">io.github.hengyunabc.endpoints.autoconfigure2.ManagementApplicationcontextHolderConfiguration</span><br></pre></td></tr></table></figure><p><strong>仔细对比，可以发现是spring boot 2下面修改了<code>ManagementContextConfiguration</code>的包名，所以对于Endpoint天然是兼容的，不同的模块自己编绎就可以了。</strong></p><h2 id="HealthIndicator的兼容"><a href="#HealthIndicator的兼容" class="headerlink" title="HealthIndicator的兼容"></a>HealthIndicator的兼容</h2><p>类似Endpoint的处理，spring boot 1/2的代码分别放不同的autoconfigure模块里，然后各自的<code>@Configuration</code>类分别使用<code>@ConditionalOnSpringBoot1/@ConditionalOnSpringBoot2</code>来判断。</p><h2 id="通过集成测试保证兼容性"><a href="#通过集成测试保证兼容性" class="headerlink" title="通过集成测试保证兼容性"></a>通过集成测试保证兼容性</h2><p>还是以endpoints-spring-boot-autoconfigure1模块为例。</p><p>这个模块是为spring boot 1准备的，则它的集成测试要配置为spring boot 2。</p><p>参考相关的代码：<a href="https://github.com/hengyunabc/endpoints-spring-boot-starter/tree/endpoints-spring-boot-starter-parent-0.0.1/endpoints-spring-boot-autoconfigure1/src/it" target="_blank" rel="noopener">查看</a></p><ul><li>在<code>springboot2demo/pom.xml</code>里依赖spring boot 2</li><li>在<code>verify.groovy</code>里检测应用是否启动成功</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>通过ASM分析现有的starter里不兼容的类</li><li>配置注入通过<code>BinderUtils</code>解决</li><li>各自的<code>@Configuration</code>类分别用<code>@ConditionalOnSpringBoot1/@ConditionalOnSpringBoot2</code>来判断</li><li>代码分模块：commons放公共逻辑, autoconfigure1/autoconfigure2 对应 spring boot 1/2的自动装配，starter给应用依赖</li><li>Endpoint的Configuration入口是ManagementContextConfiguration，因为spring boot 2里修改了package，所以直接在<code>spring.factories</code>里配置即可</li><li>通过集成测试保证兼容性</li><li>如果某一天，不再需要支持spring boot 1了，则直接把autoconfigure1模块去掉即可</li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul><li><a href="https://github.com/hengyunabc/spring-boot-utils" target="_blank" rel="noopener">https://github.com/hengyunabc/spring-boot-utils</a> </li><li><a href="https://github.com/hengyunabc/springboot-classchecker" target="_blank" rel="noopener">https://github.com/hengyunabc/springboot-classchecker</a></li><li><a href="https://github.com/hengyunabc/endpoints-spring-boot-starter" target="_blank" rel="noopener">https://github.com/hengyunabc/endpoints-spring-boot-starter</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Spring Boot 2正式发布已经有段时间，应用升级之前，starter先要升级，那么如何支持Spring Boot 2？&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="技术" scheme="http://hengyunabc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://hengyunabc.github.io/tags/java/"/>
    
      <category term="spring" scheme="http://hengyunabc.github.io/tags/spring/"/>
    
      <category term="spring-boot" scheme="http://hengyunabc.github.io/tags/spring-boot/"/>
    
      <category term="asm" scheme="http://hengyunabc.github.io/tags/asm/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin里的Extension Functions实现原理分析</title>
    <link href="http://hengyunabc.github.io/kotlin-extension-functions/"/>
    <id>http://hengyunabc.github.io/kotlin-extension-functions/</id>
    <published>2018-07-24T00:58:28.000Z</published>
    <updated>2018-10-31T16:09:41.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kotlin里的Extension-Functions"><a href="#Kotlin里的Extension-Functions" class="headerlink" title="Kotlin里的Extension Functions"></a>Kotlin里的Extension Functions</h2><p>Kotlin里有所谓的扩展函数(Extension Functions)，支持给现有的java类增加函数。</p><ul><li><a href="https://kotlinlang.org/docs/reference/extensions.html" target="_blank" rel="noopener">https://kotlinlang.org/docs/reference/extensions.html</a></li></ul><p>比如给<code>String</code>增加一个<code>hello</code>函数，可以这样子写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun String.hello(world : String) : String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello "</span> + world + <span class="keyword">this</span>.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(args: Array&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"abc"</span>.hello(<span class="string">"world"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在main函数里，直接可以在<code>String</code>上调用<code>hello</code>函数。</p><p>执行后，输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world3</span><br></pre></td></tr></table></figure><p>可以看到在<code>hello</code>函数里的<code>this</code>引用的是<code>&quot;abc&quot;</code>。</p><p>刚开始看到这个语法还是比较新奇的，那么怎样实现的呢？<strong>如果不同的库都增加了同样的函数会不会冲突？</strong></p><p>反编绎生成的字节码，结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">hello</span><span class="params">(@NotNull String $receiver, @NotNull String world)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"hello "</span> + world + $receiver.length();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(@NotNull String[] args)</span> </span>&#123;</span><br><span class="line">  System.out.println(hello(<span class="string">"abc"</span>, <span class="string">"world"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，实际上是增加了一个static public final函数。</p><p><strong>并且新增加的函数是在自己的类里的，并不是在String类里。即不同的库新增加的扩展函数都是自己类里的，不会冲突。</strong></p><h2 id="lombok-里的-ExtensionMethod-实现"><a href="#lombok-里的-ExtensionMethod-实现" class="headerlink" title="lombok 里的 @ExtensionMethod 实现"></a>lombok 里的 @ExtensionMethod 实现</h2><p>lombok里也提供了类似的<code>@ExtensionMethod</code>支持。</p><ul><li><a href="https://projectlombok.org/features/experimental/ExtensionMethod" target="_blank" rel="noopener">https://projectlombok.org/features/experimental/ExtensionMethod</a></li></ul><p>和上面的例子一样，给String类增加一个<code>hello</code>函数：</p><ul><li>需要定义一个<code>class Extensions</code></li><li>再用<code>@ExtensionMethod</code>声明</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extensions</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hello</span><span class="params">(String receiver, String world)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + world + receiver.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@ExtensionMethod</span>(&#123;</span><br><span class="line">        Extensions.class</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"abc"</span>.hello(<span class="string">"world"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后，输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world3</span><br></pre></td></tr></table></figure><p>可以看到在<code>hello</code>函数里，第一个参数<code>String receiver</code>就是<code>&quot;abc&quot;</code>本身。</p><p>和上面kotlin的例子不一样的是，kotlin里直接可以用<code>this</code>。</p><p>生成的字节码反编绎结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extensions</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hello</span><span class="params">(String receiver, String world)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello "</span> + world + receiver.length();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(Extensions.hello(<span class="string">"abc"</span>, <span class="string">"world"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到所谓的<code>@ExtensionMethod</code>实际上也是一个语法糖。</p><h2 id="设计动机"><a href="#设计动机" class="headerlink" title="设计动机"></a>设计动机</h2><ul><li><a href="https://kotlinlang.org/docs/reference/extensions.html#motivation" target="_blank" rel="noopener">https://kotlinlang.org/docs/reference/extensions.html#motivation</a> </li></ul><p>据kotlin的文档：各种<code>FileUtils</code>，<code>StringUtils</code>类很麻烦。</p><p>比如像下面处理<code>List</code>，在java里可以用<code>java.util.Collections</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line">Collections.swap(list, Collections.binarySearch(list,</span><br><span class="line">    Collections.max(otherList)),</span><br><span class="line">    Collections.max(list));</span><br></pre></td></tr></table></figure><p>简化下import，可以变为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line">swap(list, binarySearch(list, max(otherList)), max(list));</span><br></pre></td></tr></table></figure><p>但是还不够清晰，各种<code>import *</code>也是比较烦的。利用扩展函数，可以直接这样子写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line">list.swap(list.binarySearch(otherList.max()), list.max());</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>kotlin的Extension Functions和lombok的<code>@ExtensionMethod</code>实际上都是增加public static final函数</li><li>不同的库增加的同样的Extension Functions不会冲突</li><li>设计的动机是减少各种utils类。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Kotlin里的Extension-Functions&quot;&gt;&lt;a href=&quot;#Kotlin里的Extension-Functions&quot; class=&quot;headerlink&quot; title=&quot;Kotlin里的Extension Functions&quot;&gt;&lt;/a&gt;Kotli
      
    
    </summary>
    
      <category term="技术" scheme="http://hengyunabc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://hengyunabc.github.io/tags/java/"/>
    
      <category term="asm" scheme="http://hengyunabc.github.io/tags/asm/"/>
    
      <category term="bytecode" scheme="http://hengyunabc.github.io/tags/bytecode/"/>
    
      <category term="kotlin" scheme="http://hengyunabc.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>思考gRPC ：为什么是protobuf</title>
    <link href="http://hengyunabc.github.io/thinking-about-grpc-protobuf/"/>
    <id>http://hengyunabc.github.io/thinking-about-grpc-protobuf/</id>
    <published>2018-07-17T20:03:54.000Z</published>
    <updated>2018-10-31T16:09:41.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>谈到RPC，就避免不了序列化的话题。</p><p>gRPC默认的序列化方式是protobuf，原因很简单，因为两者都是google发明的，哈哈。</p><p>在当初Google开源protobuf时，很多人就期待是否能把RPC的实现也一起开源出来。没想到最终出来的是gRPC，终于补全了这一块。</p><h2 id="跨语言的序列化方案"><a href="#跨语言的序列化方案" class="headerlink" title="跨语言的序列化方案"></a>跨语言的序列化方案</h2><p>事实上的跨语言序列化方案只有三个： protobuf, thrift, json。</p><ul><li>json体积太大，并且缺少类型信息，实际上只用在RESTful接口上，并没有看到RPC框架会默认选json做序列化的。</li></ul><p>国内一些大公司的使用情况：</p><ul><li><p>protobuf ，腾迅，百度等</p></li><li><p>thrift，小米，美团等</p></li><li><p>hessian， 阿里用的是自己维护的版本，有js/cpp的实现，因为阿里主用java，更多是历史原因。</p></li></ul><h3 id="序列化里的类型信息"><a href="#序列化里的类型信息" class="headerlink" title="序列化里的类型信息"></a>序列化里的类型信息</h3><p>序列化就是把对象转换为二进制数据，反序列化就把二进制数据转换为对象。</p><p>各种序列化库层出不穷，其中有一个重要的区别：<strong>类型信息存放在哪</strong>？ </p><p>可以分为三种：</p><ol><li><p>不保存类型信息</p><p> 典型的是各种json序列化库，优点是灵活，缺点是使用的双方都要知道类型是什么。当然有一些json库会提供一些扩展，偷偷把类型信息插入到json里。</p></li><li><p>类型信息保存到序列化结果里</p><p> 比如java自带的序列化，hessian等。缺点是类型信息冗余。比如RPC里每一个request都要带上类型。因此有一种常见的RPC优化手段就是两端协商之后，后续的请求不需要再带上类型信息。</p></li><li><p>在生成代码里带上类型信息</p><p> 通常是在IDL文件里写好package和类名，生成的代码直接就有了类型信息。比如protobuf, thrift。缺点是需要生成代码，双方都要知道IDL文件。</p></li></ol><p>类型信息看起来是一个小事，但在安全上却会出大问题，后面会讨论。</p><h2 id="实际使用中序列化有哪些问题"><a href="#实际使用中序列化有哪些问题" class="headerlink" title="实际使用中序列化有哪些问题"></a>实际使用中序列化有哪些问题</h2><p>这里讨论的是没有IDL定义的序列化方案，比如java自带的序列化，hessian, 各种json库。</p><ul><li>大小莫名增加，比如用户不小心向map里put了大对象。</li><li>对象之间互相引用，用户根本不清楚序列化到底会产生什么结果，可能新加一个field就不小心被序列化了</li><li>enum类新增加的不能识别，当两端的类版本不一致时就会出错</li><li>哪些字段应该跳过序列化 ，不同的库都有不同的 @Ignore ，没有通用的方案</li><li>很容易把一些奇怪的类传过来，然后对端报ClassNotFoundException</li><li>新版本jdk新增加的类不支持，需要序列化库不断升级，如果没人维护就悲剧了</li><li>库本身的代码质量不高，或者API设计不好容易出错，比如<a href="https://blog.csdn.net/hengyunabc/article/details/7764509" target="_blank" rel="noopener">kryo</a></li></ul><h3 id="gRPC是protobuf的一个插件"><a href="#gRPC是protobuf的一个插件" class="headerlink" title="gRPC是protobuf的一个插件"></a>gRPC是protobuf的一个插件</h3><p>以gRPC官方的Demo为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The greeting service definition.</span></span><br><span class="line">service Greeter &#123;</span><br><span class="line">  <span class="comment">// Sends a greeting</span></span><br><span class="line">  <span class="function">rpc <span class="title">SayHello</span> <span class="params">(HelloRequest)</span> <span class="title">returns</span> <span class="params">(HelloReply)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The request message containing the user's name.</span></span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  string name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The response message containing the greetings</span></span><br><span class="line">message HelloReply &#123;</span><br><span class="line">  string message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到rpc的定义也是写在proto文件里的。实际上gRPC是protobuf的一个扩展，通过扩展生成gRPC相关的代码。</p><h2 id="protobuf并不是完美解决方案"><a href="#protobuf并不是完美解决方案" class="headerlink" title="protobuf并不是完美解决方案"></a>protobuf并不是完美解决方案</h2><p>在protobuf出来以后，也不断出现新的方案。比如 </p><ul><li><a href="https://github.com/capnproto/capnproto" target="_blank" rel="noopener">https://github.com/capnproto/capnproto</a></li><li><a href="https://github.com/google/flatbuffers" target="_blank" rel="noopener">https://github.com/google/flatbuffers</a></li><li><a href="https://avro.apache.org/" target="_blank" rel="noopener">https://avro.apache.org/</a></li></ul><p>protobuf的一些缺点：</p><ul><li>缺少map/set的支持(proto3支持map)</li><li><a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="noopener">Varint</a>编码会消耗CPU</li><li>会影响CPU缓存，比如比较大的int32从4字节用Varint表示是5字节就不对齐了</li><li><p>解码时要复制一份内存，不能做原地内存引用的优化</p><p>  protobuf在google 2008年公开的，内部使用自然更早。当时带宽还比较昂贵，现在人们对速度的关注胜过带宽了。</p></li></ul><p>protobuf需要生成代码的确有点麻烦，所以会有基于java annotation的方案：</p><ul><li><a href="https://github.com/protostuff/protostuff" target="_blank" rel="noopener">https://github.com/protostuff/protostuff</a></li></ul><p>同样thrift有：</p><ul><li><a href="https://github.com/facebookarchive/swift" target="_blank" rel="noopener">https://github.com/facebookarchive/swift</a></li></ul><h2 id="序列化库的速度问题"><a href="#序列化库的速度问题" class="headerlink" title="序列化库的速度问题"></a>序列化库的速度问题</h2><p>总有序列化库跳出来说自己速度最快，其实很多时候猫腻很多。事有反常必有妖。</p><p>常见的加快速度的手段有：</p><ul><li><p>threadlocal的byte array</p><p>  当序列化一个大对象后，threadlocal的byte array增大，然后不能及时释放。如果线程池越大，则占用的内存会越多。fastjson采用一种动态缩小的处理办法，但不能从根本解决这个问题。</p></li><li><p>用asm的方式生成代码，避免反射调用getter/setter</p><p>  这样会导致库代码复杂，容易有bug，并且会占用内存。</p></li><li><p>循环引用用ID标识对象</p><p>  kryo要求注册类型的顺序是统一的，因为它要为类型分配ID，然后在处理循环引用时，把同样的对象直接用ID来标识，这样子可以大大减少体积。<br>  但是用户在使用时，调用代码的顺序可能是不确定的，注册上去的ID也可能不一样，那么反序列化就会有问题。<br>  kryo的API还不是线程安全的，很容易踩坑。</p></li></ul><p>在benchmark里protobuf的速度在前列，并不是最快。但是protobuf用生成代码的方式保证了内存占用，时间占用不会出问题。</p><h2 id="序列化被人忽视的安全性问题"><a href="#序列化被人忽视的安全性问题" class="headerlink" title="序列化被人忽视的安全性问题"></a>序列化被人忽视的安全性问题</h2><h3 id="序列化漏洞危害很大"><a href="#序列化漏洞危害很大" class="headerlink" title="序列化漏洞危害很大"></a>序列化漏洞危害很大</h3><ol><li>序列化漏洞通常比较严重，容易造成任意代码执行</li><li>序列化漏洞在很多语言里都会有，比如Python Pickle序列化漏洞。</li></ol><p>很多程序员不理解为什么反序列化可以造成任意代码执行。</p><p>反序列化漏洞到底是怎么工作的呢？很难直接描述清楚，这些漏洞都有很精巧的设计，把多个地方的代码串联起来。可以参考这个demo，跑起来调试下就可以有直观的印象：</p><ul><li><a href="https://github.com/hengyunabc/dubbo-apache-commons-collections-bug" target="_blank" rel="noopener">https://github.com/hengyunabc/dubbo-apache-commons-collections-bug</a></li></ul><p>这里有两个生成java序列化漏洞代码的工具：</p><ul><li><a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial</a></li><li><a href="https://github.com/mbechler/marshalsec" target="_blank" rel="noopener">https://github.com/mbechler/marshalsec</a></li></ul><h3 id="常见的库怎样防止反序列化漏洞"><a href="#常见的库怎样防止反序列化漏洞" class="headerlink" title="常见的库怎样防止反序列化漏洞"></a>常见的库怎样防止反序列化漏洞</h3><p>下面来看下常见的序列化方案是怎么防止反序列化漏洞的：</p><ol><li><p>Java Serialization</p><ul><li>jdk里增加了一个filter机制 <a href="http://openjdk.java.net/jeps/290" target="_blank" rel="noopener">http://openjdk.java.net/jeps/290</a> ，这个一开始是出现在jdk9上的，后面移值回jdk6/7/8上，如果安装的jdk版本是比较新的，可以找到相关的类</li><li>Oracle打算废除java序列化：<a href="https://www.infoworld.com/article/3275924/java/oracle-plans-to-dump-risky-java-serialization.html" target="_blank" rel="noopener">https://www.infoworld.com/article/3275924/java/oracle-plans-to-dump-risky-java-serialization.html</a> </li></ul></li><li><p>jackson-databind</p><ul><li>jackson-databind里是过滤掉一些已知的类，参见<a href="https://github.com/FasterXML/jackson-databind/blob/jackson-databind-2.9.6/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java" target="_blank" rel="noopener">SubTypeValidator.java</a></li><li>jackson-databind的<a href="https://github.com/FasterXML/jackson-databind/issues?q=is%3Aissue+label%3ACVE+is%3Aclosed" target="_blank" rel="noopener">CVE issue列表</a></li></ul></li><li><p>fastjson</p><ul><li>fastjson通过一个<code>denyList</code>来过滤掉一些危险类的package，参见<a href="https://github.com/alibaba/fastjson/blob/1.2.7.sec01/src/main/java/com/alibaba/fastjson/parser/ParserConfig.java#L169" target="_blank" rel="noopener">ParserConfig.java</a></li><li>fastjson在新版本里<code>denyList</code>改为通过hashcode来隐藏掉package信息，但通过这个<a href="https://github.com/alibaba/fastjson/blob/1.2.47/src/test/java/com/alibaba/json/bvt/parser/deser/deny/DenyTest5.java" target="_blank" rel="noopener"><code>DenyTest5</code></a>可以知道还是过滤掉常见危险类的package</li><li>fastjson在新版本里默认把<code>autoType</code>的功能禁止掉了</li></ul></li></ol><p>所以总结下来，要么白名单，要么黑名单。当然黑名单机制不能及时更新，业务方得不断升jar包，非常蛋疼。白名单是比较彻底的解决方案。</p><h3 id="为什么protobuf没有序列化漏洞"><a href="#为什么protobuf没有序列化漏洞" class="headerlink" title="为什么protobuf没有序列化漏洞"></a>为什么protobuf没有序列化漏洞</h3><p><strong>这些序列化漏洞的根本原因是：没有控制序列化的类型范围</strong></p><p>为什么在protobuf里并没有这些反序列化问题？</p><ul><li>protobuf在IDL里定义好了package范围</li><li>protobuf的代码都是自动生成的，怎么处理二进制数据都是固定的</li></ul><p>protobuf把一切都框住了，少了灵活性，自然就少漏洞。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>应该重视反序列化漏洞，毕竟Oracle都不得不考虑把java序列化废弃了</li><li>序列化漏洞的根本原因是：没有控制序列化的类型范围</li><li>防止序列化漏洞，最好是使用白名单</li><li>protobuf通过IDL生成代码，严格控制了类型范围</li><li>protobuf不是完美的方案，但是作为跨语言的序列化事实方案之一，IDL生成代码比较麻烦也不是啥大问题</li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul><li><a href="https://github.com/protostuff/protostuff" target="_blank" rel="noopener">https://github.com/protostuff/protostuff</a></li><li><a href="https://github.com/facebookarchive/swift" target="_blank" rel="noopener">https://github.com/facebookarchive/swift</a></li><li><a href="http://openjdk.java.net/jeps/290" target="_blank" rel="noopener">http://openjdk.java.net/jeps/290</a></li><li><a href="https://www.infoworld.com/article/3275924/java/oracle-plans-to-dump-risky-java-serialization.html" target="_blank" rel="noopener">https://www.infoworld.com/article/3275924/java/oracle-plans-to-dump-risky-java-serialization.html</a> </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;谈到RPC，就避免不了序列化的话题。&lt;/p&gt;
&lt;p&gt;gRPC默认的序列化方式是protobuf，原因很简单，因为两者都是google发明的，
      
    
    </summary>
    
      <category term="技术" scheme="http://hengyunabc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="security" scheme="http://hengyunabc.github.io/tags/security/"/>
    
      <category term="rpc" scheme="http://hengyunabc.github.io/tags/rpc/"/>
    
      <category term="http2" scheme="http://hengyunabc.github.io/tags/http2/"/>
    
      <category term="grpc" scheme="http://hengyunabc.github.io/tags/grpc/"/>
    
      <category term="protobuf" scheme="http://hengyunabc.github.io/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>思考gRPC ：为什么是HTTP/2</title>
    <link href="http://hengyunabc.github.io/thinking-about-grpc-http2/"/>
    <id>http://hengyunabc.github.io/thinking-about-grpc-http2/</id>
    <published>2018-07-13T20:03:54.000Z</published>
    <updated>2018-10-31T16:09:41.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>gRPC是google开源的高性能跨语言的RPC方案。gRPC的设计目标是在任何环境下运行，支持可插拔的负载均衡，跟踪，运行状况检查和身份验证。它不仅支持数据中心内部和跨数据中心的服务调用，它也适用于分布式计算的最后一公里，将设备，移动应用程序和浏览器连接到后端服务。</p><ul><li><a href="https://grpc.io/" target="_blank" rel="noopener">https://grpc.io/</a></li><li><a href="https://github.com/grpc/grpc" target="_blank" rel="noopener">https://github.com/grpc/grpc</a></li></ul><h3 id="GRPC设计的动机和原则"><a href="#GRPC设计的动机和原则" class="headerlink" title="GRPC设计的动机和原则"></a>GRPC设计的动机和原则</h3><ul><li><a href="https://grpc.io/blog/principles" target="_blank" rel="noopener">https://grpc.io/blog/principles</a></li></ul><p>个人觉得官方的文章令人印象深刻的点：</p><ul><li>内部有Stubby的框架，但是它不是基于任何一个标准的</li><li>支持任意环境使用，支持物联网、手机、浏览器</li><li>支持stream和流控</li></ul><h3 id="HTTP-2是什么"><a href="#HTTP-2是什么" class="headerlink" title="HTTP/2是什么"></a>HTTP/2是什么</h3><p>在正式讨论gRPC为什么选择HTTP/2之前，我们先来简单了解下HTTP/2。 </p><p>HTTP/2可以简单用一个图片来介绍：</p><p><img src="/img/http2.svg" alt="HTTP/2"></p><p>来自：<a href="https://hpbn.co/" target="_blank" rel="noopener">https://hpbn.co/</a></p><p>可以看到：</p><ul><li>HTTP/1里的header对应HTTP/2里的 HEADERS frame</li><li>HTTP/1里的payload对应HTTP/2里的 DATA frame</li></ul><p>在Chrome浏览器里，打开<code>chrome://net-internals/#http2</code>，可以看到http2链接的信息。</p><p><img src="/img/chrome-http2.png" alt="chrome-http2"></p><p>目前很多网站都已经跑在HTTP/2上了，包括alibaba。</p><h3 id="gRPC-over-HTTP-2"><a href="#gRPC-over-HTTP-2" class="headerlink" title="gRPC over HTTP/2"></a>gRPC over HTTP/2</h3><p>准确来说gRPC设计上是分层的，底层支持不同的协议，目前gRPC支持：</p><ul><li><a href="https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md" target="_blank" rel="noopener">gRPC over HTTP2</a></li><li><a href="https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md" target="_blank" rel="noopener">gRPC Web</a></li></ul><p>但是大多数情况下，讨论都是基于gRPC over HTTP2。</p><p>下面从一个真实的gRPC <code>SayHello</code>请求，查看它在HTTP/2上是怎样实现的。用wireshark抓包：</p><p><img src="/img/wireshark-grpc.png" alt="wireshark-grpc"></p><p>可以看到下面这些Header：</p><ul><li>Header: :authority: localhost:50051</li><li>Header: :path: /helloworld.Greeter/SayHello</li><li>Header: :method: POST</li><li>Header: :scheme: http</li><li>Header: content-type: application/grpc</li><li>Header: user-agent: grpc-java-netty/1.11.0</li></ul><p>然后请求的参数在DATA frame里：</p><ul><li>GRPC Message: /helloworld.Greeter/SayHello, Request</li></ul><p>简而言之，gGRPC把元数据放到HTTP/2 Headers里，请求参数序列化之后放到 DATA frame里。</p><h3 id="基于HTTP-2-协议的优点"><a href="#基于HTTP-2-协议的优点" class="headerlink" title="基于HTTP/2 协议的优点"></a>基于HTTP/2 协议的优点</h3><h4 id="HTTP-2-是一个公开的标准"><a href="#HTTP-2-是一个公开的标准" class="headerlink" title="HTTP/2 是一个公开的标准"></a>HTTP/2 是一个公开的标准</h4><p>Google本身把这个事情想清楚了，它并没有把内部的Stubby开源，而是选择重新做。现在技术越来越开放，私有协议的空间越来越小。</p><h4 id="HTTP-2-是一个经过实践检验的标准"><a href="#HTTP-2-是一个经过实践检验的标准" class="headerlink" title="HTTP/2 是一个经过实践检验的标准"></a>HTTP/2 是一个经过实践检验的标准</h4><p>HTTP/2是先有实践再有标准，这个很重要。很多不成功的标准都是先有一大堆厂商讨论出标准后有实现，导致混乱而不可用，比如CORBA。HTTP/2的前身是Google的<a href="https://en.wikipedia.org/wiki/SPDY" target="_blank" rel="noopener">SPDY</a>，没有Google的实践和推动，可能都不会有HTTP/2。</p><h4 id="HTTP-2-天然支持物联网、手机、浏览器"><a href="#HTTP-2-天然支持物联网、手机、浏览器" class="headerlink" title="HTTP/2 天然支持物联网、手机、浏览器"></a>HTTP/2 天然支持物联网、手机、浏览器</h4><p>实际上先用上HTTP/2的也是手机和手机浏览器。移动互联网推动了HTTP/2的发展和普及。</p><h3 id="基于HTTP-2-多语言客户端实现容易"><a href="#基于HTTP-2-多语言客户端实现容易" class="headerlink" title="基于HTTP/2 多语言客户端实现容易"></a>基于HTTP/2 多语言客户端实现容易</h3><p>只讨论协议本身的实现，不考虑序列化。</p><ul><li>每个流行的编程语言都会有成熟的HTTP/2 Client</li><li>HTTP/2 Client是经过充分测试，可靠的</li><li>用Client发送HTTP/2请求的难度远低于用socket发送数据包/解析数据包</li></ul><h4 id="HTTP-2支持Stream和流控"><a href="#HTTP-2支持Stream和流控" class="headerlink" title="HTTP/2支持Stream和流控"></a>HTTP/2支持Stream和流控</h4><p>在业界，有很多支持stream的方案，比如基于websocket的，或者<a href="https://github.com/rsocket/rsocket" target="_blank" rel="noopener">rsocket</a>。但是这些方案都不是通用的。</p><p>HTTP/2里的Stream还可以设置优先级，尽管在rpc里可能用的比较少，但是一些复杂的场景可能会用到。</p><h4 id="基于HTTP-2-在Gateway-Proxy很容易支持"><a href="#基于HTTP-2-在Gateway-Proxy很容易支持" class="headerlink" title="基于HTTP/2 在Gateway/Proxy很容易支持"></a>基于HTTP/2 在Gateway/Proxy很容易支持</h4><ul><li>nginx对gRPC的支持：<a href="https://www.nginx.com/blog/nginx-1-13-10-grpc/" target="_blank" rel="noopener">https://www.nginx.com/blog/nginx-1-13-10-grpc/</a></li><li>envoy对gRPC的支持：<a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/grpc#" target="_blank" rel="noopener">https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/grpc#</a></li></ul><h4 id="HTTP-2-安全性有保证"><a href="#HTTP-2-安全性有保证" class="headerlink" title="HTTP/2 安全性有保证"></a>HTTP/2 安全性有保证</h4><ul><li>HTTP/2 天然支持SSL，当然gRPC可以跑在clear text协议（即不加密）上。 </li><li>很多私有协议的rpc可能自己包装了一层TLS支持，使用起来也非常复杂。开发者是否有足够的安全知识？使用者是否配置对了？运维者是否能正确理解？</li><li>HTTP/2 在公有网络上的传输上有保证。比如这个<a href="https://en.wikipedia.org/wiki/CRIME" target="_blank" rel="noopener">CRIME攻击</a>，私有协议很难保证没有这样子的漏洞。</li></ul><h4 id="HTTP-2-鉴权成熟"><a href="#HTTP-2-鉴权成熟" class="headerlink" title="HTTP/2 鉴权成熟"></a>HTTP/2 鉴权成熟</h4><ul><li>从HTTP/1发展起来的鉴权系统已经很成熟了，可以无缝用在HTTP/2上</li><li>可以从前端到后端完全打通的鉴权，不需要做任何转换适配</li></ul><p>比如传统的rpc dubbo，需要写一个dubbo filter，还要考虑把鉴权相关的信息通过thread local传递进去。rpc协议本身也需要支持。总之，非常复杂。实际上绝大部分公司里的rpc都是没有鉴权的，可以随便调。</p><h3 id="基于HTTP-2-的缺点"><a href="#基于HTTP-2-的缺点" class="headerlink" title="基于HTTP/2 的缺点"></a>基于HTTP/2 的缺点</h3><ul><li><p>rpc的元数据的传输不够高效</p><p>  尽管HPAC可以压缩HTTP Header，但是对于rpc来说，确定一个函数调用，可以简化为一个int，只要两端去协商过一次，后面直接查表就可以了，不需要像HPAC那样编码解码。<br>  可以考虑专门对gRPC做一个优化过的HTTP/2解析器，减少一些通用的处理，感觉可以提升性能。</p></li><li><p>HTTP/2 里一次gRPC调用需要解码两次</p><p>  一次是HEADERS frame，一次是DATA frame。</p></li><li><p>HTTP/2 标准本身是只有一个TCP连接，但是实际在gRPC里是会有多个TCP连接，使用时需要注意。</p></li></ul><p>gRPC选择基于HTTP/2，那么它的性能肯定不会是最顶尖的。但是对于rpc来说中庸的qps可以接受，通用和兼容性才是最重要的事情。</p><ul><li>官方的benchmark：<a href="https://grpc.io/docs/guides/benchmarking.html" target="_blank" rel="noopener">https://grpc.io/docs/guides/benchmarking.html</a></li><li><a href="https://github.com/hank-whu/rpc-benchmark" target="_blank" rel="noopener">https://github.com/hank-whu/rpc-benchmark</a> </li></ul><h3 id="Google制定标准的能力"><a href="#Google制定标准的能力" class="headerlink" title="Google制定标准的能力"></a>Google制定标准的能力</h3><p>近10年来，Google制定标准的能力越来越强。下面列举一些标准：</p><ul><li>HTTP/2</li><li>WebP图片格式</li><li>WebRTC 网页即时通信</li><li>VP9/AV1 视频编码标准</li><li>Service Worker/PWA</li></ul><p>当然google也并不都会成功，很多事情它想推也失败了，比如Chrome的Native Client。</p><p><strong>gRPC目前是k8s生态里的事实标准。 gRPC是否会成为更多地方，更大领域的RPC标准？</strong></p><h3 id="为什么会出现gRPC"><a href="#为什么会出现gRPC" class="headerlink" title="为什么会出现gRPC"></a>为什么会出现gRPC</h3><p>准确来说为什么会出现基于HTTP/2的RPC？</p><p>个人认为一个重要的原因是，在Cloud Native的潮流下，开放互通的需求必然会产生基于HTTP/2的RPC。即使没有gRPC，也会有其它基于HTTP/2的RPC。</p><p>gRPC在Google的内部也是先用在Google Cloud Platform和公开的API上：<a href="https://opensource.google.com/projects/grpc" target="_blank" rel="noopener">https://opensource.google.com/projects/grpc</a></p><p>尽管gRPC它可能替换不了内部的RPC实现，但是在开放互通的时代，不止在k8s上，gRPC会有越来越多的舞台可以施展。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li><a href="https://hpbn.co/" target="_blank" rel="noopener">https://hpbn.co/</a></li><li><a href="https://grpc.io/blog/loadbalancing" target="_blank" rel="noopener">https://grpc.io/blog/loadbalancing</a></li><li><a href="https://http2.github.io/faq" target="_blank" rel="noopener">https://http2.github.io/faq</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;gRPC是google开源的高性能跨语言的RPC方案。gRPC的设计目标是在任何环境下运行，支持可插拔的负载均衡，跟踪，运行状况检查和身份验
      
    
    </summary>
    
      <category term="技术" scheme="http://hengyunabc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="rpc" scheme="http://hengyunabc.github.io/tags/rpc/"/>
    
      <category term="http2" scheme="http://hengyunabc.github.io/tags/http2/"/>
    
      <category term="grpc" scheme="http://hengyunabc.github.io/tags/grpc/"/>
    
  </entry>
  
  <entry>
    <title>OpenJDK里的AsmTools简介</title>
    <link href="http://hengyunabc.github.io/openjdk-asmtools/"/>
    <id>http://hengyunabc.github.io/openjdk-asmtools/</id>
    <published>2018-07-12T21:03:54.000Z</published>
    <updated>2018-10-31T16:09:41.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><a href="https://wiki.openjdk.java.net/display/CodeTools/asmtools" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/CodeTools/asmtools</a> </li></ul><p>在OpenJDK里有一个<code>AsmTools</code>项目，用来生成正确的或者不正确的java <code>.class</code>文件，主要用来测试和验证。</p><p>我们知道直接修改<code>.class</code>文件是很麻烦的，虽然有一些图形界面的工具，但还是很麻烦。</p><p>以前我的办法是用<a href="https://static.javadoc.io/org.ow2.asm/asm/5.2/org/objectweb/asm/util/ASMifier.html" target="_blank" rel="noopener">ASMifier</a>从<code>.class</code>文件生成asm java代码，再修改代码，生成新的<code>.class</code>文件，非常麻烦。</p><p><code>AsmTools</code>引入了两种表示<code>.class</code>文件的语法：</p><ul><li><p>JASM</p><p>  用类似java本身的语法来定义类和函数，字节码指令则很像传统的汇编。</p></li><li><p>JCOD </p><p>  整个<code>.class</code>用容器的方式来表示，可以很清楚表示类文件的结构。</p></li></ul><p>重要的是两种语法的文件都是可以和<code>.class</code>互相转换的。</p><h2 id="构建AsmTools"><a href="#构建AsmTools" class="headerlink" title="构建AsmTools"></a>构建AsmTools</h2><p>官方文档： <a href="https://wiki.openjdk.java.net/display/CodeTools/How+to+build+AsmTools" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/CodeTools/How+to+build+AsmTools</a> </p><p>需要有jdk8和ant。</p><ol><li><p>clone代码</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hg clone http://hg.openjdk.java.net/code-tools/asmtools</span><br></pre></td></tr></table></figure></li><li><p>编绎</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd asmtools/build</span><br><span class="line">ant</span><br></pre></td></tr></table></figure><p> 打包出来的zip包里有一个<code>asmtools.jar</code>。</p></li></ol><p>也可以在这里下载我构建的：<a href="https://github.com/hengyunabc/hengyunabc.github.io/files/2188258/asmtools-7.0.zip" target="_blank" rel="noopener">https://github.com/hengyunabc/hengyunabc.github.io/files/2188258/asmtools-7.0.zip</a></p><h2 id="测试简单的java类"><a href="#测试简单的java类" class="headerlink" title="测试简单的java类"></a>测试简单的java类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先用javac来编绎： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac Test.java</span><br></pre></td></tr></table></figure><h3 id="查看JASM语法结果"><a href="#查看JASM语法结果" class="headerlink" title="查看JASM语法结果"></a>查看JASM语法结果</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar asmtools.jar jdis Test.class</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">super public class Test</span><br><span class="line">version 52:0</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public Method &quot;&lt;init&gt;&quot;:&quot;()V&quot;</span><br><span class="line">stack 1 locals 1</span><br><span class="line">&#123;</span><br><span class="line">aload_0;</span><br><span class="line">invokespecialMethod java/lang/Object.&quot;&lt;init&gt;&quot;:&quot;()V&quot;;</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Method main:&quot;([Ljava/lang/String;)V&quot;</span><br><span class="line">stack 2 locals 1</span><br><span class="line">&#123;</span><br><span class="line">getstaticField java/lang/System.out:&quot;Ljava/io/PrintStream;&quot;;</span><br><span class="line">ldcString &quot;hello&quot;;</span><br><span class="line">invokevirtualMethod java/io/PrintStream.println:&quot;(Ljava/lang/String;)V&quot;;</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; // end Class Test</span><br></pre></td></tr></table></figure><h3 id="查看JCOD语法结果"><a href="#查看JCOD语法结果" class="headerlink" title="查看JCOD语法结果"></a>查看JCOD语法结果</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar asmtools.jar jdec Test.class</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">  0xCAFEBABE;</span><br><span class="line">  0; // minor version</span><br><span class="line">  52; // version</span><br><span class="line">  [] &#123; // Constant Pool</span><br><span class="line">    ; // first element is empty</span><br><span class="line">    class #2; // #1</span><br><span class="line">    Utf8 &quot;Test&quot;; // #2</span><br><span class="line">    class #4; // #3</span><br><span class="line">    Utf8 &quot;java/lang/Object&quot;; // #4</span><br><span class="line">    Utf8 &quot;&lt;init&gt;&quot;; // #5</span><br><span class="line">    Utf8 &quot;()V&quot;; // #6</span><br><span class="line">    Utf8 &quot;Code&quot;; // #7</span><br><span class="line">    Method #3 #9; // #8</span><br><span class="line">    NameAndType #5 #6; // #9</span><br><span class="line">    Utf8 &quot;LineNumberTable&quot;; // #10</span><br><span class="line">    Utf8 &quot;LocalVariableTable&quot;; // #11</span><br><span class="line">    Utf8 &quot;this&quot;; // #12</span><br><span class="line">    Utf8 &quot;LTest;&quot;; // #13</span><br><span class="line">    Utf8 &quot;main&quot;; // #14</span><br><span class="line">    Utf8 &quot;([Ljava/lang/String;)V&quot;; // #15</span><br><span class="line">    Field #17 #19; // #16</span><br><span class="line">    class #18; // #17</span><br><span class="line">    Utf8 &quot;java/lang/System&quot;; // #18</span><br><span class="line">    NameAndType #20 #21; // #19</span><br><span class="line">    Utf8 &quot;out&quot;; // #20</span><br><span class="line">    Utf8 &quot;Ljava/io/PrintStream;&quot;; // #21</span><br><span class="line">    String #23; // #22</span><br><span class="line">    Utf8 &quot;hello&quot;; // #23</span><br><span class="line">    Method #25 #27; // #24</span><br><span class="line">    class #26; // #25</span><br><span class="line">    Utf8 &quot;java/io/PrintStream&quot;; // #26</span><br><span class="line">    NameAndType #28 #29; // #27</span><br><span class="line">    Utf8 &quot;println&quot;; // #28</span><br><span class="line">    Utf8 &quot;(Ljava/lang/String;)V&quot;; // #29</span><br><span class="line">    Utf8 &quot;args&quot;; // #30</span><br><span class="line">    Utf8 &quot;[Ljava/lang/String;&quot;; // #31</span><br><span class="line">    Utf8 &quot;SourceFile&quot;; // #32</span><br><span class="line">    Utf8 &quot;Test.java&quot;; // #33</span><br><span class="line">  &#125; // Constant Pool</span><br><span class="line"></span><br><span class="line">  0x0021; // access</span><br><span class="line">  #1;// this_cpx</span><br><span class="line">  #3;// super_cpx</span><br><span class="line"></span><br><span class="line">  [] &#123; // Interfaces</span><br><span class="line">  &#125; // Interfaces</span><br><span class="line"></span><br><span class="line">  [] &#123; // fields</span><br><span class="line">  &#125; // fields</span><br><span class="line"></span><br><span class="line">  [] &#123; // methods</span><br><span class="line">    &#123; // Member</span><br><span class="line">      0x0001; // access</span><br><span class="line">      #5; // name_cpx</span><br><span class="line">      #6; // sig_cpx</span><br><span class="line">      [] &#123; // Attributes</span><br><span class="line">        Attr(#7) &#123; // Code</span><br><span class="line">          1; // max_stack</span><br><span class="line">          1; // max_locals</span><br><span class="line">          Bytes[]&#123;</span><br><span class="line">            0x2AB70008B1;</span><br><span class="line">          &#125;</span><br><span class="line">          [] &#123; // Traps</span><br><span class="line">          &#125; // end Traps</span><br><span class="line">          [] &#123; // Attributes</span><br><span class="line">            Attr(#10) &#123; // LineNumberTable</span><br><span class="line">              [] &#123; // LineNumberTable</span><br><span class="line">                0  2;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; // end LineNumberTable</span><br><span class="line">            ;</span><br><span class="line">            Attr(#11) &#123; // LocalVariableTable</span><br><span class="line">              [] &#123; // LocalVariableTable</span><br><span class="line">                0 5 12 13 0;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; // end LocalVariableTable</span><br><span class="line">          &#125; // Attributes</span><br><span class="line">        &#125; // end Code</span><br><span class="line">      &#125; // Attributes</span><br><span class="line">    &#125; // Member</span><br><span class="line">    ;</span><br><span class="line">    &#123; // Member</span><br><span class="line">      0x0009; // access</span><br><span class="line">      #14; // name_cpx</span><br><span class="line">      #15; // sig_cpx</span><br><span class="line">      [] &#123; // Attributes</span><br><span class="line">        Attr(#7) &#123; // Code</span><br><span class="line">          2; // max_stack</span><br><span class="line">          1; // max_locals</span><br><span class="line">          Bytes[]&#123;</span><br><span class="line">            0xB200101216B60018;</span><br><span class="line">            0xB1;</span><br><span class="line">          &#125;</span><br><span class="line">          [] &#123; // Traps</span><br><span class="line">          &#125; // end Traps</span><br><span class="line">          [] &#123; // Attributes</span><br><span class="line">            Attr(#10) &#123; // LineNumberTable</span><br><span class="line">              [] &#123; // LineNumberTable</span><br><span class="line">                0  5;</span><br><span class="line">                8  6;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; // end LineNumberTable</span><br><span class="line">            ;</span><br><span class="line">            Attr(#11) &#123; // LocalVariableTable</span><br><span class="line">              [] &#123; // LocalVariableTable</span><br><span class="line">                0 9 30 31 0;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; // end LocalVariableTable</span><br><span class="line">          &#125; // Attributes</span><br><span class="line">        &#125; // end Code</span><br><span class="line">      &#125; // Attributes</span><br><span class="line">    &#125; // Member</span><br><span class="line">  &#125; // methods</span><br><span class="line"></span><br><span class="line">  [] &#123; // Attributes</span><br><span class="line">    Attr(#32) &#123; // SourceFile</span><br><span class="line">      #33;</span><br><span class="line">    &#125; // end SourceFile</span><br><span class="line">  &#125; // Attributes</span><br><span class="line">&#125; // end class Test</span><br></pre></td></tr></table></figure><h2 id="从JASM-JCOD语法文件生成类文件"><a href="#从JASM-JCOD语法文件生成类文件" class="headerlink" title="从JASM/JCOD语法文件生成类文件"></a>从JASM/JCOD语法文件生成类文件</h2><p>因为是等价表达，可以从JASM生成<code>.class</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar asmtools.jar jasm Test.jasm</span><br></pre></td></tr></table></figure><p>同样可以从JCOD生成<code>.class</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar asmtools.jar jcoder Test.jasm</span><br></pre></td></tr></table></figure><p>更多使用方法参考： <a href="https://wiki.openjdk.java.net/display/CodeTools/Chapter+2#Chapter2-Jasm.1" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/CodeTools/Chapter+2#Chapter2-Jasm.1</a></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul><li><p><a href="https://wiki.openjdk.java.net/display/CodeTools/Appendix+A" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/CodeTools/Appendix+A</a> JASM Syntax</p></li><li><p><a href="https://wiki.openjdk.java.net/display/CodeTools/Appendix+B" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/CodeTools/Appendix+B</a> JCOD Syntax</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://wiki.openjdk.java.net/display/CodeTools/asmtool
      
    
    </summary>
    
      <category term="技术" scheme="http://hengyunabc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://hengyunabc.github.io/tags/java/"/>
    
      <category term="jvm" scheme="http://hengyunabc.github.io/tags/jvm/"/>
    
      <category term="asm" scheme="http://hengyunabc.github.io/tags/asm/"/>
    
  </entry>
  
  <entry>
    <title>从JVM heap dump里查找没有关闭文件的引用</title>
    <link href="http://hengyunabc.github.io/jvm-heap-dump-find-fd/"/>
    <id>http://hengyunabc.github.io/jvm-heap-dump-find-fd/</id>
    <published>2018-07-02T16:01:41.000Z</published>
    <updated>2018-10-31T16:09:41.371Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近排查一个文件没有关闭的问题，记录一下。</p><p>哪些文件没有关闭是比较容易找到的，查看进程的fd(File Descriptor)就可以。但是确定fd是在哪里被打开，在哪里被引用的就复杂点，特别是在没有重启应用的情况下。<br>在JVM里可以通过heap dump比较方便地反查对象的引用，从而找到泄露的代码。</p><p>以下面简单的demo为例，Demo会创建一个临时文件，并且没有close掉：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">File tempFile = File.createTempFile(<span class="string">"test"</span>, <span class="string">"ttt"</span>);</span><br><span class="line">FileInputStream fi = <span class="keyword">new</span> FileInputStream(tempFile);</span><br><span class="line"></span><br><span class="line">System.in.read();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过文件名查找对应的fd"><a href="#通过文件名查找对应的fd" class="headerlink" title="通过文件名查找对应的fd"></a>通过文件名查找对应的fd</h3><p>进程打开的文件在OS里有对应的fd(File Descriptor)，可以用lsof命令或者直接在linux下到<code>/proc</code>目录下查看。</p><p>以demo为例，可以找到test文件的fd是12：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ls -alh /proc/11278/fd/</span><br><span class="line">total 0</span><br><span class="line">dr-x------ 2 admin users  0 Jun 30 18:20 .</span><br><span class="line">dr-xr-xr-x 8 admin users  0 Jun 30 18:20 ..</span><br><span class="line">lrwx------ 1 admin users 64 Jun 30 18:20 0 -&gt; /dev/pts/0</span><br><span class="line">lrwx------ 1 admin users 64 Jun 30 18:20 1 -&gt; /dev/pts/0</span><br><span class="line">lr-x------ 1 admin users 64 Jun 30 18:24 11 -&gt; /dev/urandom</span><br><span class="line">lr-x------ 1 admin users 64 Jun 30 18:24 12 -&gt; /tmp/test7607712940880692142ttt</span><br></pre></td></tr></table></figure><h3 id="对进程进行heap-dump"><a href="#对进程进行heap-dump" class="headerlink" title="对进程进行heap dump"></a>对进程进行heap dump</h3><p>使用jmap命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=heap.bin 11278</span><br></pre></td></tr></table></figure><h3 id="通过OQL查询java-io-FileDescriptor对象"><a href="#通过OQL查询java-io-FileDescriptor对象" class="headerlink" title="通过OQL查询java.io.FileDescriptor对象"></a>通过OQL查询<code>java.io.FileDescriptor</code>对象</h3><p>对于每一个打开的文件在JVM里都有一个<code>java.io.FileDescriptor</code>对象。查看下源码，可以发现<code>FileDescriptor</code>里有一个<code>fd</code>字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDescriptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fd;</span><br></pre></td></tr></table></figure><p>所以需要查找到fd等于12的<code>FileDescriptor</code>，QOL语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select s from java.io.FileDescriptor s where s.fd == 12</span><br></pre></td></tr></table></figure><h4 id="使用VisualVM里的OQL控制台查询"><a href="#使用VisualVM里的OQL控制台查询" class="headerlink" title="使用VisualVM里的OQL控制台查询"></a>使用VisualVM里的OQL控制台查询</h4><p>在jdk8里自带VisualVM，jdk9之后可以单独下载：<a href="https://visualvm.github.io/" target="_blank" rel="noopener">https://visualvm.github.io/</a></p><p>把heap dump文件导入VisualVM里，然后在“OQL控制台”查询上面的语句，结果是：</p><p><img src="/img/visualvm-query.png" alt="visualvm-query"></p><p>再可以查询到parent，引用相关的对象。</p><p><img src="/img/visualvm-object.png" alt="visualvm-object"></p><h4 id="使用jhat查询"><a href="#使用jhat查询" class="headerlink" title="使用jhat查询"></a>使用jhat查询</h4><p>除了VisualVM还有其它很多heap dump工具，在jdk里还自带一个jhat工具，尽管在jdk9之后移除掉了，但是个人还是比较喜欢这个工具，因为它是一个web接口的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhat -port 7000 heap.bin</span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:7000/oql/" target="_blank" rel="noopener">http://localhost:7000/oql/</a> ，可以在浏览器里查询OQL：</p><p><img src="/img/jhat-query.png" alt="jhat-query"></p><p>打开链接可以查看具体的信息</p><p><img src="/img/jhat-object.png" alt="jhat-object"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>先找出没有关闭文件的fd</li><li>从heap dump里据fd找出对应的<code>java.io.FileDescriptor</code>对象，再找到相关引用</li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li><a href="https://visualvm.github.io/" target="_blank" rel="noopener">ViauslVM</a></li><li><a href="http://cr.openjdk.java.net/~sundar/8022483/webrev.01/raw_files/new/src/share/classes/com/sun/tools/hat/resources/oqlhelp.html" target="_blank" rel="noopener">Object Query Language (OQL)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;最近排查一个文件没有关闭的问题，记录一下。&lt;/p&gt;
&lt;p&gt;哪些文件没有关闭是比较容易找到的，查看进程的fd(File Descriptor)
      
    
    </summary>
    
      <category term="技术" scheme="http://hengyunabc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://hengyunabc.github.io/tags/java/"/>
    
      <category term="jvm" scheme="http://hengyunabc.github.io/tags/jvm/"/>
    
      <category term="fd" scheme="http://hengyunabc.github.io/tags/fd/"/>
    
      <category term="visualvm" scheme="http://hengyunabc.github.io/tags/visualvm/"/>
    
  </entry>
  
  <entry>
    <title>深入Spring Boot：快速集成Dubbo + Hystrix</title>
    <link href="http://hengyunabc.github.io/spring-boot-dubbo-hystrix/"/>
    <id>http://hengyunabc.github.io/spring-boot-dubbo-hystrix/</id>
    <published>2018-06-14T14:01:41.000Z</published>
    <updated>2018-10-31T16:09:41.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Hystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能。</p><p>Dubbo是Alibaba开源的，目前国内最流行的java rpc框架。</p><p>本文介绍在spring应用里，怎么把Dubbo和Hystrix结合起来使用。</p><ul><li><a href="https://github.com/Netflix/Hystrix" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix</a></li><li><a href="https://github.com/apache/incubator-dubbo" target="_blank" rel="noopener">https://github.com/apache/incubator-dubbo</a></li></ul><h2 id="Spring-Boot应用"><a href="#Spring-Boot应用" class="headerlink" title="Spring Boot应用"></a>Spring Boot应用</h2><p>Demo地址： <a href="https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-spring-boot-hystrix" target="_blank" rel="noopener">https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-spring-boot-hystrix</a></p><h3 id="生成dubbo集成spring-boot的应用"><a href="#生成dubbo集成spring-boot的应用" class="headerlink" title="生成dubbo集成spring boot的应用"></a>生成dubbo集成spring boot的应用</h3><p>对于不熟悉dubbo 集成spring boot应用的同学，可以在这里直接生成dubbo + spring boot的工程： <a href="http://start.dubbo.io/" target="_blank" rel="noopener">http://start.dubbo.io/</a></p><h3 id="配置spring-cloud-starter-netflix-hystrix"><a href="#配置spring-cloud-starter-netflix-hystrix" class="headerlink" title="配置spring-cloud-starter-netflix-hystrix"></a>配置spring-cloud-starter-netflix-hystrix</h3><p>spring boot官方提供了对hystrix的集成，直接在pom.xml里加入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在Application类上增加<code>@EnableHystrix</code>来启用hystrix starter：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrix</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderApplication</span> </span>&#123;</span><br></pre></td></tr></table></figure><h3 id="配置Provider端"><a href="#配置Provider端" class="headerlink" title="配置Provider端"></a>配置Provider端</h3><p>在Dubbo的Provider上增加<code>@HystrixCommand</code>配置，这样子调用就会经过Hystrix代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(version = <span class="string">"1.0.0"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@HystrixCommand</span>(commandProperties = &#123;</span><br><span class="line">                    <span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.requestVolumeThreshold"</span>, value = <span class="string">"10"</span>),</span><br><span class="line">                    <span class="meta">@HystrixProperty</span>(name = <span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>, value = <span class="string">"2000"</span>) &#125;)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// System.out.println("async provider received: " + name);</span></span><br><span class="line">        <span class="comment">// return "annotation: hello, " + name;</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Exception to show hystrix enabled."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置Consumer端"><a href="#配置Consumer端" class="headerlink" title="配置Consumer端"></a>配置Consumer端</h3><p>对于Consumer端，则可以增加一层method调用，并在method上配置<code>@HystrixCommand</code>。当调用出错时，会走到<code>fallbackMethod = &quot;reliable&quot;</code>的调用里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Reference</span>(version = <span class="string">"1.0.0"</span>)</span><br><span class="line"><span class="keyword">private</span> HelloService demoService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"reliable"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">doSayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> demoService.sayHello(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reliable</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hystrix fallback value"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的配置，很简单地就完成了Spring Boot里Dubbo + Hystrix的集成。</p><h2 id="传统Spring-Annotation应用"><a href="#传统Spring-Annotation应用" class="headerlink" title="传统Spring Annotation应用"></a>传统Spring Annotation应用</h2><p>Demo地址： <a href="https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-spring-hystrix" target="_blank" rel="noopener">https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-spring-hystrix</a></p><p>传统spring annotation应用的配置其实也很简单，和spring boot应用不同的是：</p><ol><li>显式配置Spring AOP支持：<code>@EnableAspectJAutoProxy</code></li><li>显式通过<code>@Configuration</code>配置<code>HystrixCommandAspect</code> Bean。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableDubbo</span>(scanBasePackages = <span class="string">"com.alibaba.dubbo.samples.annotation.action"</span>)</span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/spring/dubbo-consumer.properties"</span>)</span><br><span class="line"><span class="meta">@ComponentScan</span>(value = &#123;<span class="string">"com.alibaba.dubbo.samples.annotation.action"</span>&#125;)</span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HystrixCommandAspect <span class="title">hystrixCommandAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HystrixCommandAspect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hystrix集成Spring-AOP原理"><a href="#Hystrix集成Spring-AOP原理" class="headerlink" title="Hystrix集成Spring AOP原理"></a>Hystrix集成Spring AOP原理</h2><p>在上面的例子里可以看到，Hystrix对Spring的集成是通过Spring AOP来实现的。下面简单分析下实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixCommandAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hystrixCommandAnnotationPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.netflix.hystrix.contrib.javanica.annotation.HystrixCollapser)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hystrixCollapserAnnotationPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"hystrixCommandAnnotationPointcut() || hystrixCollapserAnnotationPointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">methodsAnnotatedWithHystrixCommand</span><span class="params">(<span class="keyword">final</span> ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Method method = getMethodFromTarget(joinPoint);</span><br><span class="line">        Validate.notNull(method, <span class="string">"failed to get method from joinPoint: %s"</span>, joinPoint);</span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(HystrixCommand.class) &amp;&amp; method.isAnnotationPresent(HystrixCollapser.class)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"method cannot be annotated with HystrixCommand and HystrixCollapser "</span> +</span><br><span class="line">                    <span class="string">"annotations at the same time"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MetaHolderFactory metaHolderFactory = META_HOLDER_FACTORY_MAP.get(HystrixPointcutType.of(method));</span><br><span class="line">        MetaHolder metaHolder = metaHolderFactory.create(joinPoint);</span><br><span class="line">        HystrixInvokable invokable = HystrixCommandFactory.getInstance().create(metaHolder);</span><br><span class="line">        ExecutionType executionType = metaHolder.isCollapserAnnotationPresent() ?</span><br><span class="line">                metaHolder.getCollapserExecutionType() : metaHolder.getExecutionType();</span><br><span class="line"></span><br><span class="line">        Object result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!metaHolder.isObservable()) &#123;</span><br><span class="line">                result = CommandExecutor.execute(invokable, executionType, metaHolder);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = executeObservable(invokable, executionType, metaHolder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (HystrixBadRequestException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.getCause() != <span class="keyword">null</span> ? e.getCause() : e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (HystrixRuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> hystrixRuntimeExceptionToThrowable(metaHolder, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><code>HystrixCommandAspect</code>里定义了两个注解的AspectJ Pointcut：<code>@HystrixCommand</code>, <code>@HystrixCollapser</code>。所有带这两个注解的spring bean都会经过AOP处理</li><li>在<code>@Around</code> AOP处理函数里，可以看到Hystrix会创建出<code>HystrixInvokable</code>，再通过<code>CommandExecutor</code>来执行</li></ol><h2 id="spring-cloud-starter-netflix-hystrix的代码分析"><a href="#spring-cloud-starter-netflix-hystrix的代码分析" class="headerlink" title="spring-cloud-starter-netflix-hystrix的代码分析"></a>spring-cloud-starter-netflix-hystrix的代码分析</h2><ol><li><p><code>@EnableHystrix</code> 引入了<code>@EnableCircuitBreaker</code>，<code>@EnableCircuitBreaker</code>引入了<code>EnableCircuitBreakerImportSelector</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableHystrix &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Import</span>(EnableCircuitBreakerImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableCircuitBreaker &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>EnableCircuitBreakerImportSelector</code>继承了<code>SpringFactoryImportSelector&lt;EnableCircuitBreaker&gt;</code>，使spring加载<code>META-INF/spring.factories</code>里的<code>EnableCircuitBreaker</code>声明的配置</p><p> 在<code>META-INF/spring.factories</code>里可以找到下面的配置，也就是引入了<code>HystrixCircuitBreakerConfiguration</code>。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker=\</span><br><span class="line">org.springframework.cloud.netflix.hystrix.HystrixCircuitBreakerConfiguration</span><br></pre></td></tr></table></figure></li><li><p>在<code>HystrixCircuitBreakerConfiguration</code>里可以发现创建了<code>HystrixCommandAspect</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixCircuitBreakerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HystrixCommandAspect <span class="title">hystrixCommandAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HystrixCommandAspect();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>可见<code>spring-cloud-starter-netflix-hystrix</code>实际上也是创建了<code>HystrixCommandAspect</code>来集成Hystrix。</p><p>另外<code>spring-cloud-starter-netflix-hystrix</code>里还有metrics, health, dashboard等集成。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>对于dubbo provider的<code>@Service</code>是一个spring bean，直接在上面配置<code>@HystrixCommand</code>即可</li><li><p>对于dubbo consumer的<code>@Reference</code>，可以通过加一层简单的spring method包装，配置<code>@HystrixCommand</code>即可</p></li><li><p>Hystrix本身提供<code>HystrixCommandAspect</code>来集成Spring AOP，配置了<code>@HystrixCommand</code>和<code>@HystrixCollapser</code>的spring method都会被Hystrix处理</p></li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul><li><a href="https://github.com/Netflix/Hystrix" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix</a></li><li><a href="https://github.com/apache/incubator-dubbo" target="_blank" rel="noopener">https://github.com/apache/incubator-dubbo</a></li><li><a href="http://start.dubbo.io/" target="_blank" rel="noopener">http://start.dubbo.io/</a></li><li><a href="https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#_circuit_breaker_hystrix_clients" target="_blank" rel="noopener">https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#_circuit_breaker_hystrix_clients</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;Hystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断
      
    
    </summary>
    
      <category term="技术" scheme="http://hengyunabc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="spring" scheme="http://hengyunabc.github.io/tags/spring/"/>
    
      <category term="spring-boot" scheme="http://hengyunabc.github.io/tags/spring-boot/"/>
    
      <category term="dubbo" scheme="http://hengyunabc.github.io/tags/dubbo/"/>
    
      <category term="hystrix" scheme="http://hengyunabc.github.io/tags/hystrix/"/>
    
  </entry>
  
  <entry>
    <title>优化技巧：提前if判断帮助CPU分支预测</title>
    <link href="http://hengyunabc.github.io/optimization-tip-if-vs-switch/"/>
    <id>http://hengyunabc.github.io/optimization-tip-if-vs-switch/</id>
    <published>2018-05-16T20:45:28.000Z</published>
    <updated>2018-10-31T16:09:41.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h2><p>在stackoverflow上有一个非常有名的问题：<a href="https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array" target="_blank" rel="noopener">为什么处理有序数组要比非有序数组快？</a>，可见分支预测对代码运行效率有非常大的影响。</p><p>现代CPU都支持分支预测(branch prediction)和指令流水线(instruction pipeline)，这两个结合可以极大提高CPU效率。对于像简单的if跳转，CPU是可以比较好地做分支预测的。但是对于switch跳转，CPU则没有太多的办法。switch本质上是据索引，从地址数组里取地址再跳转。</p><p>要提高代码执行效率，一个重要的原则就是尽量避免CPU把流水线清空，那么提高分支预测的成功率就非常重要。</p><p>那么对于代码里，如果某个switch分支概率很高，是否可以考虑代码层面帮CPU把判断提前，来提高代码执行效率呢？</p><h2 id="Dubbo里ChannelEventRunnable的switch判断"><a href="#Dubbo里ChannelEventRunnable的switch判断" class="headerlink" title="Dubbo里ChannelEventRunnable的switch判断"></a>Dubbo里ChannelEventRunnable的switch判断</h2><p>在<code>ChannelEventRunnable</code>里有一个switch来判断channel state，然后做对应的逻辑：<a href="https://github.com/hengyunabc/incubator-dubbo/blob/dubbo-2.6.1/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/transport/dispatcher/ChannelEventRunnable.java#L54" target="_blank" rel="noopener">查看</a></p><p>一个channel建立起来之后，超过99.9%情况它的state都是<code>ChannelState.RECEIVED</code>，那么可以考虑把这个判断提前。</p><h2 id="benchmark验证"><a href="#benchmark验证" class="headerlink" title="benchmark验证"></a>benchmark验证</h2><p>下面通过jmh来验证下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBenchMarks</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ChannelState &#123;</span><br><span class="line">CONNECTED, DISCONNECTED, SENT, RECEIVED, CAUGHT</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@State</span>(Scope.Benchmark)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutionPlan</span> </span>&#123;</span><br><span class="line"><span class="meta">@Param</span>(&#123; <span class="string">"1000000"</span> &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">public</span> ChannelState[] states = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Setup</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ChannelState[] values = ChannelState.values();</span><br><span class="line">states = <span class="keyword">new</span> ChannelState[size];</span><br><span class="line">Random random = <span class="keyword">new</span> Random(<span class="keyword">new</span> Date().getTime());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nextInt = random.nextInt(<span class="number">1000000</span>);</span><br><span class="line"><span class="keyword">if</span> (nextInt &gt; <span class="number">100</span>) &#123;</span><br><span class="line">states[i] = ChannelState.RECEIVED;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">states[i] = values[nextInt % values.length];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Fork</span>(value = <span class="number">5</span>)</span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@BenchmarkMode</span>(Mode.Throughput)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">benchSiwtch</span><span class="params">(ExecutionPlan plan, Blackhole bh)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; plan.size; ++i) &#123;</span><br><span class="line"><span class="keyword">switch</span> (plan.states[i]) &#123;</span><br><span class="line"><span class="keyword">case</span> CONNECTED:</span><br><span class="line">result += ChannelState.CONNECTED.ordinal();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DISCONNECTED:</span><br><span class="line">result += ChannelState.DISCONNECTED.ordinal();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SENT:</span><br><span class="line">result += ChannelState.SENT.ordinal();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> RECEIVED:</span><br><span class="line">result += ChannelState.RECEIVED.ordinal();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CAUGHT:</span><br><span class="line">result += ChannelState.CAUGHT.ordinal();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bh.consume(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Fork</span>(value = <span class="number">5</span>)</span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@BenchmarkMode</span>(Mode.Throughput)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">benchIfAndSwitch</span><span class="params">(ExecutionPlan plan, Blackhole bh)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; plan.size; ++i) &#123;</span><br><span class="line">ChannelState state = plan.states[i];</span><br><span class="line"><span class="keyword">if</span> (state == ChannelState.RECEIVED) &#123;</span><br><span class="line">result += ChannelState.RECEIVED.ordinal();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (state) &#123;</span><br><span class="line"><span class="keyword">case</span> CONNECTED:</span><br><span class="line">result += ChannelState.CONNECTED.ordinal();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SENT:</span><br><span class="line">result += ChannelState.SENT.ordinal();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DISCONNECTED:</span><br><span class="line">result += ChannelState.DISCONNECTED.ordinal();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> CAUGHT:</span><br><span class="line">result += ChannelState.CAUGHT.ordinal();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bh.consume(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>benchSiwtch里是纯switch判断</li><li>benchIfAndSwitch 里用一个if提前判断state是否<code>ChannelState.RECEIVED</code></li></ul><p>benchmark结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Result &quot;io.github.hengyunabc.jmh.TestBenchMarks.benchSiwtch&quot;:</span><br><span class="line">  576.745 ±(99.9%) 6.806 ops/s [Average]</span><br><span class="line">  (min, avg, max) = (490.348, 576.745, 618.360), stdev = 20.066</span><br><span class="line">  CI (99.9%): [569.939, 583.550] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Run complete. Total time: 00:06:48</span><br><span class="line"></span><br><span class="line">Benchmark                         (size)   Mode  Cnt     Score    Error  Units</span><br><span class="line">TestBenchMarks.benchIfAndSwitch  1000000  thrpt  100  1535.867 ± 61.212  ops/s</span><br><span class="line">TestBenchMarks.benchSiwtch       1000000  thrpt  100   576.745 ±  6.806  ops/s</span><br></pre></td></tr></table></figure><p>可以看到提前if判断的确提高了代码效率，这种技巧可以放在性能要求严格的地方。</p><p>Benchmark代码：<a href="https://github.com/hengyunabc/jmh-demo" target="_blank" rel="noopener">https://github.com/hengyunabc/jmh-demo</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>switch对于CPU来说难以做分支预测</li><li>某些switch条件如果概率比较高，可以考虑单独提前if判断，充分利用CPU的分支预测机制</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分支预测&quot;&gt;&lt;a href=&quot;#分支预测&quot; class=&quot;headerlink&quot; title=&quot;分支预测&quot;&gt;&lt;/a&gt;分支预测&lt;/h2&gt;&lt;p&gt;在stackoverflow上有一个非常有名的问题：&lt;a href=&quot;https://stackoverflow.com/q
      
    
    </summary>
    
      <category term="技术" scheme="http://hengyunabc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="cpu" scheme="http://hengyunabc.github.io/tags/cpu/"/>
    
      <category term="dubbo" scheme="http://hengyunabc.github.io/tags/dubbo/"/>
    
      <category term="优化" scheme="http://hengyunabc.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>深入Spring Boot：实现对Fat Jar jsp的支持</title>
    <link href="http://hengyunabc.github.io/spring-boot-fat-jar-jsp-sample/"/>
    <id>http://hengyunabc.github.io/spring-boot-fat-jar-jsp-sample/</id>
    <published>2018-05-16T19:45:28.000Z</published>
    <updated>2018-10-31T16:09:41.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="spring-boot-对于jsp支持的限制"><a href="#spring-boot-对于jsp支持的限制" class="headerlink" title="spring boot 对于jsp支持的限制"></a>spring boot 对于jsp支持的限制</h2><p>对于jsp的支持，Spring Boot官方只支持了war的打包方式，不支持fat jar。参考官方文档： <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-jsp-limitations" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-jsp-limitations</a></p><p>这里spring boot官方说是tomcat的问题，实际上是spring boot自己改变了打包格式引起的。参考之前的文章：<a href="http://hengyunabc.github.io/spring-boot-classloader/#spring-boot-1-3-%E5%92%8C-1-4-%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB">http://hengyunabc.github.io/spring-boot-classloader/#spring-boot-1-3-%E5%92%8C-1-4-%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB</a></p><p>原来的结构之下，tomcat是可以扫描到fat jar里的<code>META-INF/resources</code>目录下面的资源的。在增加了<code>BOOT-INF/classes</code>之后，则tomcat扫描不到了。</p><p>那么怎么解决这个问题呢？下面给出一种方案，来实现对spring boot fat jar/exploded directory的jsp的支持。</p><h2 id="个性化配置tomcat，把BOOT-INF-classes-加入tomcat的ResourceSet"><a href="#个性化配置tomcat，把BOOT-INF-classes-加入tomcat的ResourceSet" class="headerlink" title="个性化配置tomcat，把BOOT-INF/classes 加入tomcat的ResourceSet"></a>个性化配置tomcat，把BOOT-INF/classes 加入tomcat的ResourceSet</h2><p>在tomcat里，所有扫描到的资源都会放到所谓的<code>ResourceSet</code>里。比如servlet 3规范里的应用jar包的<code>META-INF/resources</code>就是一个<code>ResourceSet</code>。</p><p>现在需要想办法把spring boot打出来的fat jar的<code>BOOT-INF/classes</code>目录加到<code>ResourceSet</code>里。</p><p>下面通过实现tomcat的 <code>LifecycleListener</code>接口，在<code>Lifecycle.CONFIGURE_START_EVENT</code>事件里，获取到<code>BOOT-INF/classes</code>的URL，再把这个URL加入到<code>WebResourceSet</code>里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add main class fat jar/exploded directory into tomcat ResourceSet.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hengyunabc 2017-07-29</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticResourceConfigurer</span> <span class="keyword">implements</span> <span class="title">LifecycleListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Context context;</span><br><span class="line"></span><br><span class="line">StaticResourceConfigurer(Context context) &#123;</span><br><span class="line"><span class="keyword">this</span>.context = context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifecycleEvent</span><span class="params">(LifecycleEvent event)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) &#123;</span><br><span class="line">URL location = <span class="keyword">this</span>.getClass().getProtectionDomain().getCodeSource().getLocation();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ResourceUtils.isFileURL(location)) &#123;</span><br><span class="line"><span class="comment">// when run as exploded directory</span></span><br><span class="line">String rootFile = location.getFile();</span><br><span class="line"><span class="keyword">if</span> (rootFile.endsWith(<span class="string">"/BOOT-INF/classes/"</span>)) &#123;</span><br><span class="line">rootFile = rootFile.substring(<span class="number">0</span>, rootFile.length() - <span class="string">"/BOOT-INF/classes/"</span>.length() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span> File(rootFile, <span class="string">"META-INF"</span> + File.separator + <span class="string">"resources"</span>).isDirectory()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">location = <span class="keyword">new</span> File(rootFile).toURI().toURL();</span><br><span class="line">&#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can not add tomcat resources"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String locationStr = location.toString();</span><br><span class="line"><span class="keyword">if</span> (locationStr.endsWith(<span class="string">"/BOOT-INF/classes!/"</span>)) &#123;</span><br><span class="line"><span class="comment">// when run as fat jar</span></span><br><span class="line">locationStr = locationStr.substring(<span class="number">0</span>, locationStr.length() - <span class="string">"/BOOT-INF/classes!/"</span>.length() + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">location = <span class="keyword">new</span> URL(locationStr);</span><br><span class="line">&#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can not add tomcat resources"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.context.getResources().createWebResourceSet(ResourceSetType.RESOURCE_JAR, <span class="string">"/"</span>, location,</span><br><span class="line"><span class="string">"/META-INF/resources"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让spring boot embedded tomcat加载这个 <code>StaticResourceConfigurer</code>，还需要一个<code>EmbeddedServletContainerCustomizer</code>的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(name = <span class="string">"tomcat.staticResourceCustomizer.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomcatConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmbeddedServletContainerCustomizer <span class="title">staticResourceCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> EmbeddedServletContainerCustomizer() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableEmbeddedServletContainer container)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (container <span class="keyword">instanceof</span> TomcatEmbeddedServletContainerFactory) &#123;</span><br><span class="line">((TomcatEmbeddedServletContainerFactory) container)</span><br><span class="line">.addContextCustomizers(<span class="keyword">new</span> TomcatContextCustomizer() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">context.addLifecycleListener(<span class="keyword">new</span> StaticResourceConfigurer(context));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子的话，spring boot就可以支持fat jar里的jsp资源了。</p><p>demo地址： <a href="https://github.com/hengyunabc/spring-boot-fat-jar-jsp-sample" target="_blank" rel="noopener">https://github.com/hengyunabc/spring-boot-fat-jar-jsp-sample</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>spring boot改变了打包结构，导致tomcat没有办法扫描到fat jar里的<code>/BOOT-INF/classes</code></li><li>通过一个<code>StaticResourceConfigurer</code>把fat jar里的<code>/BOOT-INF/classes</code>加到tomcat的<code>ResourceSet</code>来解决问题</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;spring-boot-对于jsp支持的限制&quot;&gt;&lt;a href=&quot;#spring-boot-对于jsp支持的限制&quot; class=&quot;headerlink&quot; title=&quot;spring boot 对于jsp支持的限制&quot;&gt;&lt;/a&gt;spring boot 对于jsp支持的
      
    
    </summary>
    
      <category term="技术" scheme="http://hengyunabc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://hengyunabc.github.io/tags/java/"/>
    
      <category term="spring" scheme="http://hengyunabc.github.io/tags/spring/"/>
    
      <category term="tomcat" scheme="http://hengyunabc.github.io/tags/tomcat/"/>
    
      <category term="spring-boot" scheme="http://hengyunabc.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>深入Spring Boot：怎样排查 java.lang.ArrayStoreException</title>
    <link href="http://hengyunabc.github.io/spring-boot-ArrayStoreException/"/>
    <id>http://hengyunabc.github.io/spring-boot-ArrayStoreException/</id>
    <published>2018-03-07T16:01:41.000Z</published>
    <updated>2018-10-31T16:09:41.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java-lang-ArrayStoreException-分析"><a href="#java-lang-ArrayStoreException-分析" class="headerlink" title="java.lang.ArrayStoreException 分析"></a>java.lang.ArrayStoreException 分析</h2><p>这个demo来说明怎样排查一个spring boot 1应用升级到spring boot 2时可能出现的<code>java.lang.ArrayStoreException</code>。</p><p>demo地址：<a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-ArrayStoreException" target="_blank" rel="noopener">https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-ArrayStoreException</a></p><p>demo里有两个模块，<code>springboot1-starter</code>和<code>springboot2-demo</code>。</p><p>在<code>springboot1-starter</code>模块里，是一个简单的<code>HealthIndicator</code>实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHealthIndicator</span> <span class="keyword">extends</span> <span class="title">AbstractHealthIndicator</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doHealthCheck</span><span class="params">(Builder builder)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">builder.status(Status.UP);</span><br><span class="line">builder.withDetail(<span class="string">"hello"</span>, <span class="string">"world"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore</span>(EndpointAutoConfiguration.class)</span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(HealthIndicatorAutoConfiguration.class)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(value = &#123; HealthIndicator.class &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHealthIndicatorAutoConfiguration</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(MyHealthIndicator.class)</span><br><span class="line"><span class="meta">@ConditionalOnEnabledHealthIndicator</span>(<span class="string">"my"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> MyHealthIndicator <span class="title">myHealthIndicator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyHealthIndicator();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>springboot2-demo</code>则是一个简单的spring boot2应用，引用了<code>springboot1-starter</code>模块。</p><p>把工程导入IDE，执行<code>springboot2-demo</code>里的<code>ArrayStoreExceptionDemoApplication</code>，抛出的异常是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy</span><br><span class="line">at sun.reflect.annotation.AnnotationParser.parseClassArray(AnnotationParser.java:724) ~[na:1.8.0_112]</span><br><span class="line">at sun.reflect.annotation.AnnotationParser.parseArray(AnnotationParser.java:531) ~[na:1.8.0_112]</span><br><span class="line">at sun.reflect.annotation.AnnotationParser.parseMemberValue(AnnotationParser.java:355) ~[na:1.8.0_112]</span><br><span class="line">at sun.reflect.annotation.AnnotationParser.parseAnnotation2(AnnotationParser.java:286) ~[na:1.8.0_112]</span><br><span class="line">at sun.reflect.annotation.AnnotationParser.parseAnnotations2(AnnotationParser.java:120) ~[na:1.8.0_112]</span><br><span class="line">at sun.reflect.annotation.AnnotationParser.parseAnnotations(AnnotationParser.java:72) ~[na:1.8.0_112]</span><br><span class="line">at java.lang.Class.createAnnotationData(Class.java:3521) ~[na:1.8.0_112]</span><br><span class="line">at java.lang.Class.annotationData(Class.java:3510) ~[na:1.8.0_112]</span><br><span class="line">at java.lang.Class.createAnnotationData(Class.java:3526) ~[na:1.8.0_112]</span><br><span class="line">at java.lang.Class.annotationData(Class.java:3510) ~[na:1.8.0_112]</span><br><span class="line">at java.lang.Class.getAnnotation(Class.java:3415) ~[na:1.8.0_112]</span><br><span class="line">at java.lang.reflect.AnnotatedElement.isAnnotationPresent(AnnotatedElement.java:258) ~[na:1.8.0_112]</span><br><span class="line">at java.lang.Class.isAnnotationPresent(Class.java:3425) ~[na:1.8.0_112]</span><br><span class="line">at org.springframework.core.annotation.AnnotatedElementUtils.hasAnnotation(AnnotatedElementUtils.java:575) ~[spring-core-5.0.4.RELEASE.jar:5.0.4.RELEASE]</span><br><span class="line">at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.isHandler(RequestMappingHandlerMapping.java:177) ~[spring-webmvc-5.0.4.RELEASE.jar:5.0.4.RELEASE]</span><br><span class="line">at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.initHandlerMethods(AbstractHandlerMethodMapping.java:217) ~[spring-webmvc-5.0.4.RELEASE.jar:5.0.4.RELEASE]</span><br><span class="line">at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.afterPropertiesSet(AbstractHandlerMethodMapping.java:188) ~[spring-webmvc-5.0.4.RELEASE.jar:5.0.4.RELEASE]</span><br><span class="line">at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.afterPropertiesSet(RequestMappingHandlerMapping.java:129) ~[spring-webmvc-5.0.4.RELEASE.jar:5.0.4.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1769) ~[spring-beans-5.0.4.RELEASE.jar:5.0.4.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1706) ~[spring-beans-5.0.4.RELEASE.jar:5.0.4.RELEASE]</span><br><span class="line">... 16 common frames omitted</span><br></pre></td></tr></table></figure><h2 id="使用-Java-Exception-Breakpoint"><a href="#使用-Java-Exception-Breakpoint" class="headerlink" title="使用 Java Exception Breakpoint"></a>使用 Java Exception Breakpoint</h2><p>下面来排查这个问题。</p><p>在IDE里，新建一个断点，类型是<code>Java Exception Breakpoint</code>（如果不清楚怎么添加，可以搜索对应IDE的使用文档），异常类是上面抛出来的<code>java.lang.ArrayStoreException</code>。</p><p>当断点起效时，查看<code>AnnotationUtils.findAnnotation(Class&lt;?&gt;, Class&lt;A&gt;, Set&lt;Annotation&gt;) line: 686</code> 函数的参数。</p><p>可以发现</p><ul><li>clazz是 <code>class com.example.springboot1starter.MyHealthIndicatorAutoConfiguration$$EnhancerBySpringCGLIB$$945c1f</code></li><li>annotationType是 <code>interface org.springframework.boot.actuate.endpoint.annotation.Endpoint</code></li></ul><p>说明是尝试从<code>MyHealthIndicatorAutoConfiguration</code>里查找<code>@Endpoint</code>信息时出错的。</p><p><code>MyHealthIndicatorAutoConfiguration</code>上的确没有<code>@Endpoint</code>，<strong>但是为什么抛出<code>java.lang.ArrayStoreException</code>?</strong></p><h2 id="尝试以简单例子复现异常"><a href="#尝试以简单例子复现异常" class="headerlink" title="尝试以简单例子复现异常"></a>尝试以简单例子复现异常</h2><p>首先尝试直接 new MyHealthIndicatorAutoConfiguration ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyHealthIndicatorAutoConfiguration cc = <span class="keyword">new</span> MyHealthIndicatorAutoConfiguration();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>本以为会抛出异常来，但是发现执行正常。</p><p>再仔细看异常栈，可以发现是在<code>at java.lang.Class.getDeclaredAnnotation(Class.java:3458)</code>抛出的异常，则再尝试下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyHealthIndicatorAutoConfiguration.class.getDeclaredAnnotation(Endpoint.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现可以复现异常了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy</span><br><span class="line">at sun.reflect.annotation.AnnotationParser.parseClassArray(AnnotationParser.java:724)</span><br><span class="line">at sun.reflect.annotation.AnnotationParser.parseArray(AnnotationParser.java:531)</span><br><span class="line">at sun.reflect.annotation.AnnotationParser.parseMemberValue(AnnotationParser.java:355)</span><br><span class="line">at sun.reflect.annotation.AnnotationParser.parseAnnotation2(AnnotationParser.java:286)</span><br><span class="line">at sun.reflect.annotation.AnnotationParser.parseAnnotations2(AnnotationParser.java:120)</span><br><span class="line">at sun.reflect.annotation.AnnotationParser.parseAnnotations(AnnotationParser.java:72)</span><br><span class="line">at java.lang.Class.createAnnotationData(Class.java:3521)</span><br><span class="line">at java.lang.Class.annotationData(Class.java:3510)</span><br><span class="line">at java.lang.Class.getDeclaredAnnotation(Class.java:3458)</span><br></pre></td></tr></table></figure><h2 id="为什么会是java-lang-ArrayStoreException"><a href="#为什么会是java-lang-ArrayStoreException" class="headerlink" title="为什么会是java.lang.ArrayStoreException"></a>为什么会是java.lang.ArrayStoreException</h2><p>再仔细看异常信息：java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy</p><p><code>ArrayStoreException</code>是一个数组越界的异常，它只有一个String信息，并没有<code>cause</code>。</p><p>那么我们尝试在 <code>sun.reflect.annotation.TypeNotPresentExceptionProxy</code> 的构造函数里打断点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeNotPresentExceptionProxy</span> <span class="keyword">extends</span> <span class="title">ExceptionProxy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5565925172427947573L</span>;</span><br><span class="line">    String typeName;</span><br><span class="line">    Throwable cause;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TypeNotPresentExceptionProxy</span><span class="params">(String typeName, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.typeName = typeName;</span><br><span class="line">        <span class="keyword">this</span>.cause = cause;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在断点里，我们可以发现：</p><ul><li>typeName是 <code>org.springframework.boot.actuate.autoconfigure.EndpointAutoConfiguration</code></li><li>cause是 <code>java.lang.ClassNotFoundException: org.springframework.boot.actuate.autoconfigure.EndpointAutoConfiguration</code></li></ul><p>终于真相大白了，是找不到<code>org.springframework.boot.actuate.autoconfigure.EndpointAutoConfiguration</code>这个类。</p><p>那么它是怎么变成<code>ArrayStoreException</code>的呢？</p><p>仔细看下代码，可以发现<code>AnnotationParser.parseClassValue</code>把异常包装成为<code>Object</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sun.reflect.annotation.AnnotationParser.parseClassValue(ByteBuffer, ConstantPool, Class&lt;?&gt;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">parseClassValue</span><span class="params">(ByteBuffer buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          ConstantPool constPool,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt; container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> classIndex = buf.getShort() &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String sig = constPool.getUTF8At(classIndex);</span><br><span class="line">                <span class="keyword">return</span> parseSig(sig, container);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">                <span class="comment">// support obsolete early jsr175 format class files</span></span><br><span class="line">                <span class="keyword">return</span> constPool.getClassAt(classIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoClassDefFoundError e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TypeNotPresentExceptionProxy(<span class="string">"[unknown]"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TypeNotPresentException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TypeNotPresentExceptionProxy(e.typeName(), e.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后在<code>sun.reflect.annotation.AnnotationParser.parseClassArray(int, ByteBuffer, ConstantPool, Class&lt;?&gt;)</code>里尝试直接设置到数组里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sun.reflect.annotation.AnnotationParser.parseClassArray(int, ByteBuffer, ConstantPool, Class&lt;?&gt;)</span></span><br><span class="line">result[i] = parseClassValue(buf, constPool, container);</span><br></pre></td></tr></table></figure><p>而这里数组越界了，<code>ArrayStoreException</code>只有越界的<code>Object</code>的类型信息，也就是上面的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy</span><br></pre></td></tr></table></figure><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>发现是<code>java.lang.ClassNotFoundException: org.springframework.boot.actuate.autoconfigure.EndpointAutoConfiguration</code>，则加上<code>@ConditionalOnClass</code>的检查就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore</span>(EndpointAutoConfiguration.class)</span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(HealthIndicatorAutoConfiguration.class)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(value = &#123;HealthIndicator.class, EndpointAutoConfiguration.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHealthIndicatorAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>准确来说是spring boot2把一些类的package改了：</p><p>spring boot 1里类名是：</p><ul><li>org.springframework.boot.actuate.autoconfigure.EndpointAutoConfiguration</li></ul><p>spring boot 2里类名是：</p><ul><li>org.springframework.boot.actuate.autoconfigure.endpoint.EndpointAutoConfiguration</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>当类加载时，并不会加载它的annotation的field所引用的<code>Class&lt;?&gt;</code>，当调用<code>Class.getDeclaredAnnotation(Class&lt;A&gt;)</code>里才会加载</p><p>  以上面的例子来说，就是<code>@AutoConfigureBefore(EndpointAutoConfiguration.class)</code>里的<code>EndpointAutoConfiguration</code>并不会和<code>MyHealthIndicatorAutoConfiguration</code>一起被加载。</p></li><li><p>jdk内部的解析字节码的代码不合理，把<code>ClassNotFoundException</code>异常吃掉了</p></li><li>排查问题需要一步步深入调试</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java-lang-ArrayStoreException-分析&quot;&gt;&lt;a href=&quot;#java-lang-ArrayStoreException-分析&quot; class=&quot;headerlink&quot; title=&quot;java.lang.ArrayStoreExceptio
      
    
    </summary>
    
      <category term="技术" scheme="http://hengyunabc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://hengyunabc.github.io/tags/java/"/>
    
      <category term="spring" scheme="http://hengyunabc.github.io/tags/spring/"/>
    
      <category term="ClassLoader" scheme="http://hengyunabc.github.io/tags/ClassLoader/"/>
    
      <category term="spring-boot" scheme="http://hengyunabc.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>从java9共享内存加载modules说起</title>
    <link href="http://hengyunabc.github.io/java9-mmap-load-modules/"/>
    <id>http://hengyunabc.github.io/java9-mmap-load-modules/</id>
    <published>2018-02-23T16:01:41.000Z</published>
    <updated>2018-10-31T16:09:41.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jdk9后加载lib-modules的方式"><a href="#jdk9后加载lib-modules的方式" class="headerlink" title="jdk9后加载lib/modules的方式"></a>jdk9后加载lib/modules的方式</h2><p>从jdk的代码里可以看出来，默认的实现加载<code>lib/modules</code>是用mmap来加载的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class NativeImageBuffer &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        java.security.AccessController.doPrivileged(</span><br><span class="line">                new java.security.PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    public Void run() &#123;</span><br><span class="line">                        System.loadLibrary(&quot;jimage&quot;);</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    native static ByteBuffer getNativeMap(String imagePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在jimage动态库里最终是一个cpp实现的<code>ImageFileReader</code>来读取的。它在64位os上使用的是mmap方式：</p><p><a href="https://github.com/dmlloyd/openjdk/blob/jdk/jdk10/src/java.base/share/native/libjimage/imageFile.cpp#L44" target="_blank" rel="noopener">https://github.com/dmlloyd/openjdk/blob/jdk/jdk10/src/java.base/share/native/libjimage/imageFile.cpp#L44</a></p><p>通过共享内存启动多个jvm时会有好处：</p><ul><li>减少内存占用</li><li>加快启动速度</li></ul><p><strong>突然有个想法，怎么验证多个jvm的确共享了内存？</strong> </p><p>下面来验证一下，思路是：</p><ol><li>先获取进程的mmap信息</li><li>获取jvm进程映射<code>modules</code>的虚拟地址</li><li>从虚拟地址转换为物理地址</li><li>启动两个jvm进程，计算它们映射<code>modules</code>是否物理地址是一样的</li></ol><h3 id="linux下查看进程的mmap信息"><a href="#linux下查看进程的mmap信息" class="headerlink" title="linux下查看进程的mmap信息"></a>linux下查看进程的mmap信息</h3><ol><li>使用<code>pmap -x $pid</code>命令</li><li>直接查看 <code>cat /proc/$pid/maps</code>文件的内容</li></ol><p>启动一个jshell之后，用pmap查看mmap信息，其中RSS（resident set size）列表示真实占用的内存。：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ pmap -x 24615</span><br><span class="line">24615:   jdk9/jdk-9.0.4/bin/jshell</span><br><span class="line">Address           Kbytes     RSS   Dirty Mode  Mapping</span><br><span class="line">0000000000400000       4       4       0 r-x-- jshell</span><br><span class="line">0000000000601000       4       4       4 rw--- jshell</span><br><span class="line">000000000111b000     132     120     120 rw---   [ anon ]</span><br><span class="line">...</span><br><span class="line">00007f764192c000      88      64       0 r-x-- libnet.so</span><br><span class="line">00007f7641942000    2048       0       0 ----- libnet.so</span><br><span class="line">00007f7641b42000       4       4       4 rw--- libnet.so</span><br><span class="line">00007f7641b43000    2496     588     588 rwx--   [ anon ]</span><br><span class="line">...</span><br><span class="line">00007f7650b43000  185076    9880       0 r--s- modules</span><br><span class="line">00007f765c000000    5172    5124    5124 rw---   [ anon ]</span><br><span class="line"></span><br><span class="line">---------------- ------- ------- -------</span><br><span class="line">total kB         2554068  128756  106560</span><br></pre></td></tr></table></figure><p>我们可以找到<code>modules</code>文件的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00007f7650b43000  185076    9880       0 r--s- modules</span><br></pre></td></tr></table></figure><p>它的文件映射大小是185076kb，实际使用内存大小是9880kb。</p><h3 id="linux-kernel关于pagemap的说明"><a href="#linux-kernel关于pagemap的说明" class="headerlink" title="linux kernel关于pagemap的说明"></a>linux kernel关于pagemap的说明</h3><p>上面我们获取到了<code>modules</code>的虚拟地址，但是还需要转换为物理地址。</p><p>正常来说一个进程是没有办法知道它自己的虚拟地址对应的是什么物理地址。不过我们用linux kernel提供的信息可以读取，转换为物理地址。</p><p>linux每个进程都有个<code>/proc/$pid/pagemap</code>文件，里面记录了内存页的信息：</p><p><a href="https://www.kernel.org/doc/Documentation/vm/pagemap.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/vm/pagemap.txt</a></p><p>简而言之，在pagemap里每一个virtual page都有一个对应的64 bit的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* Bits 0-54  page frame number (PFN) if present</span><br><span class="line">* Bits 0-4   swap type if swapped</span><br><span class="line">* Bits 5-54  swap offset if swapped</span><br><span class="line">* Bit  55    pte is soft-dirty (see Documentation/vm/soft-dirty.txt)</span><br><span class="line">* Bit  56    page exclusively mapped (since 4.2)</span><br><span class="line">* Bits 57-60 zero</span><br><span class="line">* Bit  61    page is file-page or shared-anon (since 3.5)</span><br><span class="line">* Bit  62    page swapped</span><br><span class="line">* Bit  63    page present</span><br></pre></td></tr></table></figure><p>只要把虚拟地址转换为pagemap文件里的offset，就可以读取具体的virtual page信息。计算方法是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getpagesize()是系统调用</span></span><br><span class="line"><span class="comment">// 64bit是8字节</span></span><br><span class="line"><span class="keyword">long</span> virtualPageIndex = virtualAddress / getpagesize()</span><br><span class="line">offset = virtualPageIndex * <span class="number">8</span></span><br></pre></td></tr></table></figure><p>从offset里读取出来的64bit里，可以获取到page frame number，如果想要得到真正的物理地址，还需要再转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pageFrameNumber * getpagesize() 获取page的开始地址</span></span><br><span class="line"><span class="comment">// virtualAddress % getpagesize() 获取到page里的偏移地址</span></span><br><span class="line"><span class="keyword">long</span> pageFrameNumber = <span class="comment">// read from pagemap file</span></span><br><span class="line">physicalAddress = pageFrameNumber * getpagesize() + virtualAddress % getpagesize();</span><br></pre></td></tr></table></figure><h3 id="虚拟地址转换物理地址的代码"><a href="#虚拟地址转换物理地址的代码" class="headerlink" title="虚拟地址转换物理地址的代码"></a>虚拟地址转换物理地址的代码</h3><p>参考这里的代码：<a href="https://github.com/cirosantilli/linux-kernel-module-cheat/blob/master/kernel_module/user/common.h" target="_blank" rel="noopener">https://github.com/cirosantilli/linux-kernel-module-cheat/blob/master/kernel_module/user/common.h</a></p><p>得到的一个从虚拟地址转换为物理地址的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _POSIX_C_SOURCE 200809L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; /* open */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt; /* uint64_t  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; /* size_t */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; /* pread, sysconf */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> BUFSIZ = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> pfn : <span class="number">54</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> soft_dirty : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> file_page : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> swapped : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> present : <span class="number">1</span>;</span><br><span class="line">&#125; PagemapEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Parse the pagemap entry for the given virtual address.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param[out] entry      the parsed entry</span></span><br><span class="line"><span class="comment"> * @param[in]  pagemap_fd file descriptor to an open /proc/pid/pagemap file</span></span><br><span class="line"><span class="comment"> * @param[in]  vaddr      virtual address to get entry for</span></span><br><span class="line"><span class="comment"> * @return 0 for success, 1 for failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pagemap_get_entry</span><span class="params">(PagemapEntry *entry, <span class="keyword">int</span> pagemap_fd, <span class="keyword">uintptr_t</span> vaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nread;</span><br><span class="line">    <span class="keyword">ssize_t</span> ret;</span><br><span class="line">    <span class="keyword">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    nread = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (nread &lt; <span class="keyword">sizeof</span>(data)) &#123;</span><br><span class="line">        ret = pread(pagemap_fd, &amp;data, <span class="keyword">sizeof</span>(data),</span><br><span class="line">                (vaddr / sysconf(_SC_PAGE_SIZE)) * <span class="keyword">sizeof</span>(data) + nread);</span><br><span class="line">        nread += ret;</span><br><span class="line">        <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    entry-&gt;pfn = data &amp; (((<span class="keyword">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">54</span>) - <span class="number">1</span>);</span><br><span class="line">    entry-&gt;soft_dirty = (data &gt;&gt; <span class="number">54</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    entry-&gt;file_page = (data &gt;&gt; <span class="number">61</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    entry-&gt;swapped = (data &gt;&gt; <span class="number">62</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    entry-&gt;present = (data &gt;&gt; <span class="number">63</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert the given virtual address to physical using /proc/PID/pagemap.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param[out] paddr physical address</span></span><br><span class="line"><span class="comment"> * @param[in]  pid   process to convert for</span></span><br><span class="line"><span class="comment"> * @param[in] vaddr virtual address to get entry for</span></span><br><span class="line"><span class="comment"> * @return 0 for success, 1 for failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">virt_to_phys_user</span><span class="params">(<span class="keyword">uintptr_t</span> *paddr, <span class="keyword">pid_t</span> pid, <span class="keyword">uintptr_t</span> vaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> pagemap_file[BUFSIZ];</span><br><span class="line">    <span class="keyword">int</span> pagemap_fd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(pagemap_file, <span class="keyword">sizeof</span>(pagemap_file), <span class="string">"/proc/%ju/pagemap"</span>, (<span class="keyword">uintmax_t</span>)pid);</span><br><span class="line">    pagemap_fd = open(pagemap_file, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (pagemap_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PagemapEntry entry;</span><br><span class="line">    <span class="keyword">if</span> (pagemap_get_entry(&amp;entry, pagemap_fd, vaddr)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(pagemap_fd);</span><br><span class="line">    *paddr = (entry.pfn * sysconf(_SC_PAGE_SIZE)) + (vaddr % sysconf(_SC_PAGE_SIZE));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">uintptr_t</span> virt_addr;</span><br><span class="line">    <span class="keyword">uintptr_t</span> paddr;</span><br><span class="line">    <span class="keyword">int</span> return_code;</span><br><span class="line"></span><br><span class="line">    pid = strtol(argv[<span class="number">1</span>],&amp;end, <span class="number">10</span>);</span><br><span class="line">    virt_addr = strtol(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    return_code = virt_to_phys_user(&amp;paddr, pid, virt_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(return_code == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Vaddr: 0x%lx, paddr: 0x%lx \n"</span>, virt_addr, paddr);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，收集到一些可以读取pagemap信息的工具：</p><ul><li><a href="https://github.com/dwks/pagemap" target="_blank" rel="noopener">https://github.com/dwks/pagemap</a></li></ul><h3 id="检查两个jvm进程是否映射modules的物理地址一致"><a href="#检查两个jvm进程是否映射modules的物理地址一致" class="headerlink" title="检查两个jvm进程是否映射modules的物理地址一致"></a>检查两个jvm进程是否映射<code>modules</code>的物理地址一致</h3><ol><li><p>先启动两个jshell</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jps</span><br><span class="line">25105 jdk.internal.jshell.tool.JShellToolProvider</span><br><span class="line">25142 jdk.internal.jshell.tool.JShellToolProvider</span><br></pre></td></tr></table></figure></li><li><p>把上面转换地址的代码保存为<code>mymap.c</code>，再编绎</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc mymap.c -o mymap</span><br></pre></td></tr></table></figure></li><li><p>获取两个jvm的modules的虚拟地址，并转换为物理地址</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ pmap -x 25105 | grep modules</span><br><span class="line">00007f82b4b43000  185076    9880       0 r--s- modules</span><br><span class="line">$ sudo ./mymap 25105 00007f82b4b43000</span><br><span class="line">Vaddr: 0x7f82b4b43000, paddr: 0x33598000</span><br><span class="line"></span><br><span class="line">$ pmap -x 25142 | grep modules</span><br><span class="line">00007ff220504000  185076   10064       0 r--s- modules</span><br><span class="line">$ sudo ./mymap 25142 00007ff220504000</span><br><span class="line">Vaddr: 0x7ff220504000, paddr: 0x33598000</span><br></pre></td></tr></table></figure></li></ol><p>可以看到两个jvm进程映射<code>modules</code>的物理地址是一样的，证实了最开始的想法。</p><h3 id="kernel-里的-page-types-工具"><a href="#kernel-里的-page-types-工具" class="headerlink" title="kernel 里的 page-types 工具"></a>kernel 里的 page-types 工具</h3><p>其实在kernel里自带有一个工具<code>page-types</code>可以输出一个page信息，可以通过下面的方式来获取内核源码，然后自己编绎：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get <span class="built_in">source</span> linux-image-$(uname -r)</span><br><span class="line">sudo apt-get build-dep linux-image-$(uname -r)</span><br></pre></td></tr></table></figure><p>到<code>tools/vm</code>目录下面，可以直接<code>sudo make</code>编绎。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo ./page-types -p 25105</span><br><span class="line">             flagspage-count       MB  symbolic-flagslong-symbolic-flags</span><br><span class="line">0x0000000000000000         2        0  ____________________________________</span><br><span class="line">0x0000000000400000     14819       57  ______________________t_____________thp</span><br><span class="line">0x0000000000000800         1        0  ___________M________________________mmap</span><br><span class="line">0x0000000000000828        33        0  ___U_l_____M________________________uptodate,lru,mmap</span><br><span class="line">0x000000000000086c       663        2  __RU_lA____M________________________referenced,uptodate,lru,active,mmap</span><br><span class="line">0x000000000000087c         2        0  __RUDlA____M________________________referenced,uptodate,dirty,lru,active,mmap</span><br><span class="line">0x0000000000005868     10415       40  ___U_lA____Ma_b_____________________uptodate,lru,active,mmap,anonymous,swapbacked</span><br><span class="line">0x0000000000405868        29        0  ___U_lA____Ma_b_______t_____________uptodate,lru,active,mmap,anonymous,swapbacked,thp</span><br><span class="line">0x000000000000586c         5        0  __RU_lA____Ma_b_____________________referenced,uptodate,lru,active,mmap,anonymous,swapbacked</span><br><span class="line">0x0000000000005878       356        1  ___UDlA____Ma_b_____________________uptodate,dirty,lru,active,mmap,anonymous,swapbacked</span><br><span class="line">             total     26325      102</span><br></pre></td></tr></table></figure><h3 id="jdk8及之前加载jar也是使用mmap的方式"><a href="#jdk8及之前加载jar也是使用mmap的方式" class="headerlink" title="jdk8及之前加载jar也是使用mmap的方式"></a>jdk8及之前加载jar也是使用mmap的方式</h3><p>在验证了jdk9加载<code>lib/modules</code>之后，随便检查了下jdk8的进程，发现在加载jar包时，也是使用mmap的方式。</p><p>一个tomcat进程的map信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ pmap -x 27226 | grep jar</span><br><span class="line">...</span><br><span class="line">00007f42c00d4000      16      16       0 r--s- tomcat-dbcp.jar</span><br><span class="line">00007f42c09b7000    1892    1892       0 r--s- rt.jar</span><br><span class="line">00007f42c45e5000      76      76       0 r--s- catalina.jar</span><br><span class="line">00007f42c45f8000      12      12       0 r--s- tomcat-i18n-es.jar</span><br><span class="line">00007f42c47da000       4       4       0 r--s- sunec.jar</span><br><span class="line">00007f42c47db000       8       8       0 r--s- websocket-api.jar</span><br><span class="line">00007f42c47dd000       4       4       0 r--s- tomcat-juli.jar</span><br><span class="line">00007f42c47de000       4       4       0 r--s- commons-daemon.jar</span><br><span class="line">00007f42c47df000       4       4       0 r--s- bootstrap.jar</span><br></pre></td></tr></table></figure><p>可以发现一些有意思的点：</p><ul><li>所有jar包的<code>Kbytes</code> 和 <code>RSS(resident set size)</code>是相等的，也就是说整个jar包都被加载到共享内存里了</li><li>从URLClassLoader的实现代码来看，它在加载资源时，需要扫描所有的jar包，所以会导致整个jar都要被加载到内存里</li><li>对比jdk9里的<code>modules</code>，它的<code>RSS</code>并不是很高，原因是JImage的格式设计合理。所以jdk9后，jvm占用真实内存会降低。</li></ul><h3 id="jdk8及之前的-sun-zip-disableMemoryMapping-参数"><a href="#jdk8及之前的-sun-zip-disableMemoryMapping-参数" class="headerlink" title="jdk8及之前的 sun.zip.disableMemoryMapping 参数"></a>jdk8及之前的 sun.zip.disableMemoryMapping 参数</h3><ul><li><p>在jdk6里引入一个 <code>sun.zip.disableMemoryMapping</code>参数，禁止掉利用mmap来加载zip包。<a href="http://www.oracle.com/technetwork/java/javase/documentation/overview-156328.html#6u21-rev-b09" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/documentation/overview-156328.html#6u21-rev-b09</a></p></li><li><p><a href="https://bugs.openjdk.java.net/browse/JDK-8175192" target="_blank" rel="noopener">https://bugs.openjdk.java.net/browse/JDK-8175192</a> 在jdk9里把这个参数去掉了。因为jdk9之后，jdk本身存在<code>lib/modules</code> 这个文件里了。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>linux下可以用pmap来获取进程mmap信息</li><li>通过读取<code>/proc/$pid/pagemap</code>可以获取到内存页的信息，并可以把虚拟地址转换为物理地址</li><li>jdk9把类都打包到<code>lib/modules</code>，也就是JImage格式，可以减少真实内存占用</li><li>jdk9多个jvm可以共用<code>lib/modules</code>映射的内存</li><li>默认情况下jdk8及以前是用mmap来加载jar包</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;jdk9后加载lib-modules的方式&quot;&gt;&lt;a href=&quot;#jdk9后加载lib-modules的方式&quot; class=&quot;headerlink&quot; title=&quot;jdk9后加载lib/modules的方式&quot;&gt;&lt;/a&gt;jdk9后加载lib/modules的方式&lt;/
      
    
    </summary>
    
      <category term="技术" scheme="http://hengyunabc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://hengyunabc.github.io/tags/java/"/>
    
      <category term="java9" scheme="http://hengyunabc.github.io/tags/java9/"/>
    
      <category term="linux" scheme="http://hengyunabc.github.io/tags/linux/"/>
    
      <category term="mmap" scheme="http://hengyunabc.github.io/tags/mmap/"/>
    
  </entry>
  
  <entry>
    <title>2017读书总结</title>
    <link href="http://hengyunabc.github.io/reading-notes-2017/"/>
    <id>http://hengyunabc.github.io/reading-notes-2017/</id>
    <published>2017-12-26T23:51:14.000Z</published>
    <updated>2018-10-31T16:09:41.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文科类"><a href="#文科类" class="headerlink" title="文科类"></a>文科类</h2><h3 id="古董局中局-4"><a href="#古董局中局-4" class="headerlink" title="古董局中局 4"></a>古董局中局 4</h3><p><a href="https://book.douban.com/subject/26650970/" target="_blank" rel="noopener">https://book.douban.com/subject/26650970/</a></p><p>马伯庸作品，这一系列都很好看，最后一集略不足，有点圆不上的感觉。深夜看有点吓人。</p><h3 id="解读中国经济"><a href="#解读中国经济" class="headerlink" title="解读中国经济"></a>解读中国经济</h3><p><a href="https://book.douban.com/subject/11626951/" target="_blank" rel="noopener">https://book.douban.com/subject/11626951/</a></p><p>林毅夫的作品，了解到经济政策制定者，或者叫参与者的一些想法，比如新农村，比较接地气。但是回过头来看，任何一项政策都有它的不足，最终落实效果和最初的设计都会有差距。</p><h3 id="中国历代政治得失"><a href="#中国历代政治得失" class="headerlink" title="中国历代政治得失"></a>中国历代政治得失</h3><p><a href="https://book.douban.com/subject/1003479/" target="_blank" rel="noopener">https://book.douban.com/subject/1003479/</a></p><p>钱穆的作品，可以了解到各个朝代的政治制度是怎样的，不同官位的功能。先看的《历代经济变革得失》，再看的这本书，实际上应该反过来。</p><h3 id="历代经济变革得失"><a href="#历代经济变革得失" class="headerlink" title="历代经济变革得失"></a>历代经济变革得失</h3><p><a href="https://book.douban.com/subject/24851460/" target="_blank" rel="noopener">https://book.douban.com/subject/24851460/</a></p><p>印象比较深的是说儒家一心想治国平天下，开万世之太平。但是历史上经济改革做得好的人却不是儒家。儒家一心只稳定，并没有有效的经济发展手段。尽管说得有点重，但是在经济上儒家的确没什么作为。</p><h3 id="巨流河"><a href="#巨流河" class="headerlink" title="巨流河"></a>巨流河</h3><p><a href="https://book.douban.com/subject/5914484/" target="_blank" rel="noopener">https://book.douban.com/subject/5914484/</a></p><p>前国民党高官的女儿的自传，前面的内容相对大气，后面的内容就有点虚了。可以看到台湾文人的一些状态。作者居然很少写到她的丈夫还有家人，不知道是什么心态。一位老人到了暮年仍是意难平。</p><h3 id="失乐园"><a href="#失乐园" class="headerlink" title="失乐园"></a>失乐园</h3><p><a href="https://book.douban.com/subject/25891771/" target="_blank" rel="noopener">https://book.douban.com/subject/25891771/</a></p><p>渡边淳一的作品，只记得是两个人偷情的作品，写得很细腻。</p><h3 id="人民的名义"><a href="#人民的名义" class="headerlink" title="人民的名义"></a>人民的名义</h3><p>书没有想像中好看，可能电视剧更精彩点，尽管电视剧只看了部分。</p><h3 id="三体"><a href="#三体" class="headerlink" title="三体"></a>三体</h3><p>重新读了一遍。</p><h2 id="理工科类"><a href="#理工科类" class="headerlink" title="理工科类"></a>理工科类</h2><h3 id="众病之王：癌症传"><a href="#众病之王：癌症传" class="headerlink" title="众病之王：癌症传"></a>众病之王：癌症传</h3><p><a href="https://book.douban.com/subject/20507206/" target="_blank" rel="noopener">https://book.douban.com/subject/20507206/</a></p><p>这本书详细写了癌症的起因，人们认知的历史，治疗方法的原理，治疗方法的发展史，是非常值得一读的书。认真读了的话，自然会对癌症心里有数，不会受到各种流言的困扰，对自己和身边的人都有好处。</p><h3 id="医学的真相"><a href="#医学的真相" class="headerlink" title="医学的真相"></a>医学的真相</h3><p><a href="https://book.douban.com/subject/26844088/" target="_blank" rel="noopener">https://book.douban.com/subject/26844088/</a></p><p>作者以医生的角度，谈了一些自己对医学的看法或者叫真相。了解医学的人会认同作者的观点，有的人会觉得无聊。<br>这本书可以说是作者的真心剖析，但是评分却比不上《众病之王》。人们对于自己利害相关的会比较关心，非自己利害相关的就比较冷淡了。</p><h3 id="进化心理学"><a href="#进化心理学" class="headerlink" title="进化心理学"></a>进化心理学</h3><p><a href="https://book.douban.com/subject/26683297/" target="_blank" rel="noopener">https://book.douban.com/subject/26683297/</a></p><p>一开始以为这本书是跟风的，放在书架上很久了，真正读了才知道是一本好书。</p><p>进化心理学是一本真正的科学，它是提出假设，再验证的科学。它能解析很多现象，比如外婆为什么会比爷爷更喜欢你。</p><h3 id="未来简史"><a href="#未来简史" class="headerlink" title="未来简史"></a>未来简史</h3><p><a href="https://book.douban.com/subject/26943161/" target="_blank" rel="noopener">https://book.douban.com/subject/26943161/</a></p><p>《人类简史》作者的续作。其实我觉得名字并不是很准确，只能说是作者对未来的看法，并不能说是历史。</p><p>这本书和《人类简史》一样，是作者集很多前人的想法的大成。从作者对计算机的一些描述来看，作者并非所有学科都精通。</p><h3 id="地球上最伟大的表演"><a href="#地球上最伟大的表演" class="headerlink" title="地球上最伟大的表演"></a>地球上最伟大的表演</h3><p><a href="https://book.douban.com/subject/20507207/" target="_blank" rel="noopener">https://book.douban.com/subject/20507207/</a></p><p>翻译不是很好。有一些例子比较好，比如人为的选育，其实可以让物种进化非常快，比一般人的想像的要快得多。</p><h3 id="万万没想到：用理工科思维理解世界"><a href="#万万没想到：用理工科思维理解世界" class="headerlink" title="万万没想到：用理工科思维理解世界"></a>万万没想到：用理工科思维理解世界</h3><p><a href="https://book.douban.com/subject/25986341/" target="_blank" rel="noopener">https://book.douban.com/subject/25986341/</a></p><p>博客的合集，后面的很多内容是凑数的。不过从里面找到了一些书来读，还行。</p><h2 id="读书软件相关"><a href="#读书软件相关" class="headerlink" title="读书软件相关"></a>读书软件相关</h2><ul><li>书都是在手机上读的</li><li>绝大部分格式是epub，少量是pdf</li><li>大部分书是在多看上看的</li><li>网易的锅牛每天可以免费读书一个小时，就是书籍数量比较少</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>读的书没想像中的多，很多时候想写点笔记却没有动手</li><li>下了今日读条之后，读书时间变少了……考虑是否要卸载掉</li><li>还有一些技术书和乱七八糟的小说没有记录</li><li>进化相关的书比较多，看书范围需要扩展</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;文科类&quot;&gt;&lt;a href=&quot;#文科类&quot; class=&quot;headerlink&quot; title=&quot;文科类&quot;&gt;&lt;/a&gt;文科类&lt;/h2&gt;&lt;h3 id=&quot;古董局中局-4&quot;&gt;&lt;a href=&quot;#古董局中局-4&quot; class=&quot;headerlink&quot; title=&quot;古董局中局 4
      
    
    </summary>
    
      <category term="读书" scheme="http://hengyunabc.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>深入Spring Boot：排查@Transactional引起的NullPointerException</title>
    <link href="http://hengyunabc.github.io/spring-boot-transactional-nullpointerexception/"/>
    <id>http://hengyunabc.github.io/spring-boot-transactional-nullpointerexception/</id>
    <published>2017-12-14T22:58:28.000Z</published>
    <updated>2018-10-31T16:09:41.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这个demo来说明怎么排查一个<code>@Transactional</code>引起的<code>NullPointerException</code>。</p><p><a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-Transactional-NullPointerException" target="_blank" rel="noopener">https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-Transactional-NullPointerException</a></p><h2 id="定位-NullPointerException-的代码"><a href="#定位-NullPointerException-的代码" class="headerlink" title="定位 NullPointerException 的代码"></a>定位 NullPointerException 的代码</h2><p>Demo是一个简单的spring事务例子，提供了下面一个<code>StudentDao</code>，并用<code>@Transactional</code>来声明事务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">selectStudentById</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sqlSession.selectOne(<span class="string">"selectStudentById"</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Student <span class="title">finalSelectStudentById</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sqlSession.selectOne(<span class="string">"selectStudentById"</span>, id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用启动后，会依次调用<code>selectStudentById</code>和<code>finalSelectStudentById</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">studentDao.selectStudentById(<span class="number">1</span>);</span><br><span class="line">studentDao.finalSelectStudentById(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>mvn spring-boot:run</code> 或者把工程导入IDE里启动，抛出来的异常信息是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.NullPointerException</span><br><span class="line">at sample.mybatis.dao.StudentDao.finalSelectStudentById(StudentDao.java:27)</span><br><span class="line">at com.example.demo.transactional.nullpointerexception.DemoNullPointerExceptionApplication.init(DemoNullPointerExceptionApplication.java:30)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement.invoke(InitDestroyAnnotationBeanPostProcessor.java:366)</span><br><span class="line">at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:311)</span><br></pre></td></tr></table></figure><p>为什么应用代码里执行<code>selectStudentById</code>没有问题，而执行<code>finalSelectStudentById</code>就抛出<code>NullPointerException</code>?</p><p>同一个bean里，明明<code>SqlSession sqlSession</code>已经被注入了，在<code>selectStudentById</code>里它是非null的。为什么<code>finalSelectStudentById</code>函数里是null？</p><h2 id="获取实际运行时的类名"><a href="#获取实际运行时的类名" class="headerlink" title="获取实际运行时的类名"></a>获取实际运行时的类名</h2><p>当然，我们对比两个函数，可以知道是因为<code>finalSelectStudentById</code>的修饰符是<code>final</code>。但是具体原因是什么呢？</p><p>我们先在抛出异常的地方打上断点，调试代码，获取到具体运行时的<code>class</code>是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.err.println(studentDao.getClass());</span><br></pre></td></tr></table></figure><p>打印的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class sample.mybatis.dao.StudentDao$$EnhancerBySpringCGLIB$$210b005d</span><br></pre></td></tr></table></figure><p>可以看出是一个被spring aop处理过的类，但是它的具体字节码内容是什么呢？</p><h2 id="dumpclass分析"><a href="#dumpclass分析" class="headerlink" title="dumpclass分析"></a>dumpclass分析</h2><p>我们使用dumpclass工具来把jvm里的类dump出来：</p><p><a href="https://github.com/hengyunabc/dumpclass" target="_blank" rel="noopener">https://github.com/hengyunabc/dumpclass</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://search.maven.org/remotecontent?filepath=io/github/hengyunabc/dumpclass/0.0.1/dumpclass-0.0.1.jar -O dumpclass.jar</span><br></pre></td></tr></table></figure><p>找到java进程pid：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ jps</span><br><span class="line">5907 DemoNullPointerExceptionApplication</span><br></pre></td></tr></table></figure><p>把相关的类都dump下来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo java -jar dumpclass.jar 5907 &apos;sample.mybatis.dao.StudentDao*&apos; /tmp/dumpresult</span><br></pre></td></tr></table></figure><h2 id="反汇编分析"><a href="#反汇编分析" class="headerlink" title="反汇编分析"></a>反汇编分析</h2><p>用javap或者图形化工具jd-gui来反编绎<code>sample.mybatis.dao.StudentDao$$EnhancerBySpringCGLIB$$210b005d</code>。</p><p>反编绎后的结果是：</p><ol start="0"><li><code>class StudentDao$$EnhancerBySpringCGLIB$$210b005d extends StudentDao</code></li><li><p><code>StudentDao$$EnhancerBySpringCGLIB$$210b005d</code>里没有<code>finalSelectStudentById</code>相关的内容</p></li><li><p><code>selectStudentById</code>实际调用的是<code>this.CGLIB$CALLBACK_0</code>，即<code>MethodInterceptor tmp4_1</code>，等下我们实际debug，看具体的类型</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public final Student selectStudentById(long paramLong)</span><br><span class="line">&#123;</span><br><span class="line">  try</span><br><span class="line">  &#123;</span><br><span class="line">    MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0;</span><br><span class="line">    if (tmp4_1 == null)</span><br><span class="line">    &#123;</span><br><span class="line">      tmp4_1;</span><br><span class="line">      CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">    &#125;</span><br><span class="line">    MethodInterceptor tmp17_14 = this.CGLIB$CALLBACK_0;</span><br><span class="line">    if (tmp17_14 != null)</span><br><span class="line">    &#123;</span><br><span class="line">      Object[] tmp29_26 = new Object[1];</span><br><span class="line">      Long tmp35_32 = new java/lang/Long;</span><br><span class="line">      Long tmp36_35 = tmp35_32;</span><br><span class="line">      tmp36_35;</span><br><span class="line">      tmp36_35.&lt;init&gt;(paramLong);</span><br><span class="line">      tmp29_26[0] = tmp35_32;</span><br><span class="line">      return (Student)tmp17_14.intercept(this, CGLIB$selectStudentById$0$Method, tmp29_26, CGLIB$selectStudentById$0$Proxy);</span><br><span class="line">    &#125;</span><br><span class="line">    return super.selectStudentById(paramLong);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (RuntimeException|Error localRuntimeException)</span><br><span class="line">  &#123;</span><br><span class="line">    throw localRuntimeException;</span><br><span class="line">  &#125;</span><br><span class="line">  catch (Throwable localThrowable)</span><br><span class="line">  &#123;</span><br><span class="line">    throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>再来实际debug，尽管<code>StudentDao$$EnhancerBySpringCGLIB$$210b005d</code>的代码不能直接看到，但是还是可以单步执行的。</p><p>在debug时，可以看到</p><ol start="0"><li><p><code>StudentDao$$EnhancerBySpringCGLIB$$210b005d</code>里的所有field都是null</p><p> <img src="https://raw.githubusercontent.com/hengyunabc/spring-boot-inside/master/demo-Transactional-NullPointerException/cglib-field.png" alt="cglib-field"></p></li><li><p><code>this.CGLIB$CALLBACK_0</code>的实际类型是<code>CglibAopProxy$DynamicAdvisedInterceptor</code>，在这个Interceptor里实际保存了原始的target对象</p><p> <img src="https://raw.githubusercontent.com/hengyunabc/spring-boot-inside/master/demo-Transactional-NullPointerException/cglib-target.png" alt="cglib-target"></p></li><li><p><code>CglibAopProxy$DynamicAdvisedInterceptor</code>在经过<code>TransactionInterceptor</code>处理之后，最终会用反射调用自己保存的原始target对象</p></li></ol><h2 id="抛出异常的原因"><a href="#抛出异常的原因" class="headerlink" title="抛出异常的原因"></a>抛出异常的原因</h2><p>所以整理下整个分析：</p><ol start="0"><li>在使用了<code>@Transactional</code>之后，spring aop会生成一个cglib代理类，实际用户代码里<code>@Autowired</code>注入的<code>StudentDao</code>也是这个代理类的实例</li><li>cglib生成的代理类<code>StudentDao$$EnhancerBySpringCGLIB$$210b005d</code>继承自<code>StudentDao</code></li><li><code>StudentDao$$EnhancerBySpringCGLIB$$210b005d</code>里的所有field都是null</li><li><code>StudentDao$$EnhancerBySpringCGLIB$$210b005d</code>在调用<code>selectStudentById</code>，实际上通过<code>CglibAopProxy$DynamicAdvisedInterceptor</code>，最终会用反射调用自己保存的原始target对象</li><li>所以<code>selectStudentById</code>函数的调用没有问题</li></ol><p>那么为什么<code>finalSelectStudentById</code>函数里的<code>SqlSession sqlSession</code>会是null，然后抛出<code>NullPointerException</code>？</p><ol start="0"><li><code>StudentDao$$EnhancerBySpringCGLIB$$210b005d</code>里的所有field都是null</li><li><code>finalSelectStudentById</code>函数的修饰符是<code>final</code>，cglib没有办法重写这个函数</li><li>当执行到<code>finalSelectStudentById</code>里，实际执行的是原始的<code>StudentDao</code>里的代码</li><li>但是对象是<code>StudentDao$$EnhancerBySpringCGLIB$$210b005d</code>的实例，它里面的所有field都是null，所以会抛出<code>NullPointerException</code></li></ol><h2 id="解决问题办法"><a href="#解决问题办法" class="headerlink" title="解决问题办法"></a>解决问题办法</h2><ol start="0"><li>最简单的当然是把<code>finalSelectStudentById</code>函数的<code>final</code>修饰符去掉</li><li>还有一种办法，在<code>StudentDao</code>里不要直接使用<code>sqlSession</code>，而通过<code>getSqlSession()</code>函数，这样cglib也会处理<code>getSqlSession()</code>，返回原始的target对象</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>排查问题多debug，看实际运行时的对象信息</li><li>对于cglib生成类的字节码，可以用dumpclass工具来dump，再反编绎分析</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;这个demo来说明怎么排查一个&lt;code&gt;@Transactional&lt;/code&gt;引起的&lt;code&gt;NullPointer
      
    
    </summary>
    
      <category term="技术" scheme="http://hengyunabc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://hengyunabc.github.io/tags/java/"/>
    
      <category term="spring" scheme="http://hengyunabc.github.io/tags/spring/"/>
    
      <category term="spring-boot" scheme="http://hengyunabc.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>深入Spring Boot：排查 Cannot determine embedded database driver class for database type NONE</title>
    <link href="http://hengyunabc.github.io/spring-boot-database-type-none/"/>
    <id>http://hengyunabc.github.io/spring-boot-database-type-none/</id>
    <published>2017-12-09T22:58:28.000Z</published>
    <updated>2018-10-31T16:09:41.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这个demo来说明怎么一步步排查一个常见的spring boot AutoConfiguration的错误。</p><p><a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-database-type-NONE" target="_blank" rel="noopener">https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-database-type-NONE</a></p><h2 id="调试排查-Cannot-determine-embedded-database-driver-class-for-database-type-NONE-的错误"><a href="#调试排查-Cannot-determine-embedded-database-driver-class-for-database-type-NONE-的错误" class="headerlink" title="调试排查 Cannot determine embedded database driver class for database type NONE 的错误"></a>调试排查 Cannot determine embedded database driver class for database type NONE 的错误</h2><p>把工程导入IDE里，直接启动应用，抛出来的异常信息是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Error starting ApplicationContext. To display the auto-configuration report re-run your application with &apos;debug&apos; enabled.</span><br><span class="line">2017-11-29 14:26:34.478 ERROR 29736 --- [           main] o.s.b.d.LoggingFailureAnalysisReporter   :</span><br><span class="line"></span><br><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Cannot determine embedded database driver class for database type NONE</span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">If you want an embedded database please put a supported one on the classpath. If you have database settings to be loaded from a particular profile you may need to active it (no profiles are currently active).</span><br></pre></td></tr></table></figure><p>其实这时有两个思路，直接google搜索<code>Cannot determine embedded database driver class for database type NONE</code>，就可以找到解决办法。</p><p>第二种方式，仔细查看日志内容，可以发现有<code>To display the auto-configuration report re-run your application with &#39;debug&#39; enabled.</code>。</p><p>搜索下这个，就可以在spring的官方网站上找到相关的信息：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-auto-configuration.html" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-auto-configuration.html</a></p><p>就是用户只要配置了<code>debug</code>这个开关，就会把<code>auto-configuration</code> 相关的信息打印出来。</p><p>熟悉spring的环境变量注入的话，就可以知道有几种打开这个的方式：</p><ul><li>在<code>args</code>里增加<code>--debug</code></li><li>在application.properties里增加<code>debug=true</code></li><li>通过<code>-Ddebug=true</code></li></ul><h2 id="增加debug开关之后的信息"><a href="#增加debug开关之后的信息" class="headerlink" title="增加debug开关之后的信息"></a>增加<code>debug</code>开关之后的信息</h2><p>增加<code>debug</code>开关之后，可以看到打印出了错误堆栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2017-11-29 14:33:08.776 DEBUG 29907 --- [           main] o.s.b.d.LoggingFailureAnalysisReporter   : Application failed to start due to an exception</span><br><span class="line"></span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceProperties$DataSourceBeanCreationException: Cannot determine embedded database driver class for database type NONE. If you want an embedded database please put a supported one on the classpath. If you have database settings to be loaded from a particular profile you may need to active it (no profiles are currently active).</span><br><span class="line">at org.springframework.boot.autoconfigure.jdbc.DataSourceProperties.determineDriverClassName(DataSourceProperties.java:245) ~[spring-boot-autoconfigure-1.4.7.RELEASE.jar:1.4.7.RELEASE]</span><br><span class="line">at org.springframework.boot.autoconfigure.jdbc.DataSourceProperties.initializeDataSourceBuilder(DataSourceProperties.java:182) ~[spring-boot-autoconfigure-1.4.7.RELEASE.jar:1.4.7.RELEASE]</span><br><span class="line">at org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration.createDataSource(DataSourceConfiguration.java:42) ~[spring-boot-autoconfigure-1.4.7.RELEASE.jar:1.4.7.RELEASE]</span><br><span class="line">at org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration$Tomcat.dataSource(DataSourceConfiguration.java:53) ~[spring-boot-autoconfigure-1.4.7.RELEASE.jar:1.4.7.RELEASE]</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_112]</span><br></pre></td></tr></table></figure><p>抛出异常的代码是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine the driver to use based on this configuration and the environment.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the driver to use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.4.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">determineDriverClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.driverClassName)) &#123;</span><br><span class="line">Assert.state(driverClassIsLoadable(),</span><br><span class="line"><span class="string">"Cannot load driver class: "</span> + <span class="keyword">this</span>.driverClassName);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.driverClassName;</span><br><span class="line">&#125;</span><br><span class="line">String driverClassName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</span><br><span class="line">driverClassName = DatabaseDriver.fromJdbcUrl(<span class="keyword">this</span>.url).getDriverClassName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(driverClassName)) &#123;</span><br><span class="line">driverClassName = <span class="keyword">this</span>.embeddedDatabaseConnection.getDriverClassName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(driverClassName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> DataSourceBeanCreationException(<span class="keyword">this</span>.embeddedDatabaseConnection,</span><br><span class="line"><span class="keyword">this</span>.environment, <span class="string">"driver class"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> driverClassName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出来是没有找到 DataSource 的driver class，然后抛出了 <code>DataSourceBeanCreationException</code>。</p><p>那么一种解决办法是，在maven依赖里加入一些 DataSource driver class。</p><p>但是应用自己的代码里并没有使用DataSource，哪里导致spring boot要创建一个DataSource对象？</p><h2 id="哪里导致spring-boot要创建DataSource"><a href="#哪里导致spring-boot要创建DataSource" class="headerlink" title="哪里导致spring boot要创建DataSource"></a>哪里导致spring boot要创建DataSource</h2><p>从异常栈上，可以找到<code>DataSourceConfiguration$Tomcat</code> 这个类，那么查找下它的引用，可以发现它是被<code>org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration.PooledDataSourceConfiguration</code> import引入的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Conditional</span>(PooledDataSourceCondition.class)</span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(&#123; DataSource.class, XADataSource.class &#125;)</span><br><span class="line"><span class="meta">@Import</span>(&#123; DataSourceConfiguration.Tomcat.class, DataSourceConfiguration.Hikari.class,</span><br><span class="line">DataSourceConfiguration.Dbcp.class, DataSourceConfiguration.Dbcp2.class,</span><br><span class="line">DataSourceConfiguration.Generic.class &#125;)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSourceConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 <code>PooledDataSourceConfiguration</code> 是怎么生效的呢？从代码上可以看到<code>@Conditional(PooledDataSourceCondition.class)</code>。</p><p>那么再看<code>PooledDataSourceCondition</code>的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> AnyNestedCondition&#125; that checks that either &#123;<span class="doctag">@code</span> spring.datasource.type&#125;</span></span><br><span class="line"><span class="comment"> * is set or &#123;<span class="doctag">@link</span> PooledDataSourceAvailableCondition&#125; applies.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSourceCondition</span> <span class="keyword">extends</span> <span class="title">AnyNestedCondition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">PooledDataSourceCondition() &#123;</span><br><span class="line"><span class="keyword">super</span>(ConfigurationPhase.PARSE_CONFIGURATION);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.datasource"</span>, name = <span class="string">"type"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExplicitType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Conditional</span>(PooledDataSourceAvailableCondition.class)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSourceAvailable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PooledDataSourceCondition</code>引入了<code>@Conditional(PooledDataSourceAvailableCondition.class)</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Condition&#125; to test if a supported connection pool is available.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSourceAvailableCondition</span> <span class="keyword">extends</span> <span class="title">SpringBootCondition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConditionOutcome <span class="title">getMatchOutcome</span><span class="params">(ConditionContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">ConditionMessage.Builder message = ConditionMessage</span><br><span class="line">.forCondition(<span class="string">"PooledDataSource"</span>);</span><br><span class="line"><span class="keyword">if</span> (getDataSourceClassLoader(context) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ConditionOutcome</span><br><span class="line">.match(message.foundExactly(<span class="string">"supported DataSource"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ConditionOutcome</span><br><span class="line">.noMatch(message.didNotFind(<span class="string">"supported DataSource"</span>).atAll());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the class loader for the &#123;<span class="doctag">@link</span> DataSource&#125; class. Used to ensure that</span></span><br><span class="line"><span class="comment"> * the driver class can actually be loaded by the data source.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context the condition context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the class loader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ClassLoader <span class="title">getDataSourceClassLoader</span><span class="params">(ConditionContext context)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; dataSourceClass = <span class="keyword">new</span> DataSourceBuilder(context.getClassLoader())</span><br><span class="line">.findType();</span><br><span class="line"><span class="keyword">return</span> (dataSourceClass == <span class="keyword">null</span> ? <span class="keyword">null</span> : dataSourceClass.getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码里，可以看到是尝试查找<code>dataSourceClass</code>，如果找到，条件就成立。那么debug下，可以发现查找到的<code>dataSourceClass</code>是：<code>org.apache.tomcat.jdbc.pool.DataSource</code> 。</p><p>那么再看下<code>org.apache.tomcat.jdbc.pool.DataSource</code>这个类是从哪里来的呢？</p><p>从maven依赖树可以看到，依赖是来自：<code>spring-boot-starter-jdbc</code>。所以是应用依赖了<code>spring-boot-starter-jdbc</code>，但是并没有配置<code>DataSource</code>引起的问题。</p><h2 id="问题解决办法"><a href="#问题解决办法" class="headerlink" title="问题解决办法"></a>问题解决办法</h2><p>有两种：</p><ol><li>没有使用到<code>DataSource</code>，则可以把<code>spring-boot-starter-jdbc</code>的依赖去掉，这样就不会触发spring boot相关的代码</li><li>把spring boot自动初始化<code>DataSource</code>相关的代码禁止掉</li></ol><p>禁止的办法有两种：</p><ol><li><p>在main函数上配置exclude</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication(exclude = &#123; DataSourceAutoConfiguration.class, DataSourceTransactionManagerAutoConfiguration.class &#125;)</span><br></pre></td></tr></table></figure></li><li><p>在application.properties里配置：</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration</span><br></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol start="0"><li>应用没有使用到<code>DataSource</code>，但是在pom.xml里引入了<code>spring-boot-starter-jdbc</code></li><li><code>spring-boot-starter-jdbc</code>带入了<code>tomcat-jdbc</code>，它里面有<code>org.apache.tomcat.jdbc.pool.DataSource</code></li><li>spring boot里的<code>PooledDataSourceConfiguration</code>，判断classpath下面有<code>DataSource</code>的实现类，尝试去创建<code>DataSource</code> bean</li><li>在初始化<code>DataSourceProperties</code>时，尝试通过jdbc的url来探测driver class</li><li>因为应用并没有配置url，所以最终在<code>DataSourceProperties.determineDriverClassName()</code>里抛出<code>Cannot determine embedded database driver class for database type NONE</code></li></ol><p>最后：</p><ul><li>排查spring boot的AutoConfiguration问题时，可以按异常栈，一层层排查<code>Configuration</code>是怎么引入的，再排查<code>Condition</code>具体的判断代码。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;这个demo来说明怎么一步步排查一个常见的spring boot AutoConfiguration的错误。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://hengyunabc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://hengyunabc.github.io/tags/java/"/>
    
      <category term="spring" scheme="http://hengyunabc.github.io/tags/spring/"/>
    
      <category term="spring-boot" scheme="http://hengyunabc.github.io/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>深入Spring Boot：排查expected single matching bean but found 2的异常</title>
    <link href="http://hengyunabc.github.io/spring-boot-expected-single-but-found-2/"/>
    <id>http://hengyunabc.github.io/spring-boot-expected-single-but-found-2/</id>
    <published>2017-12-09T20:58:28.000Z</published>
    <updated>2018-10-31T16:09:41.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这个demo来说明怎么排查一个常见的spring expected single matching bean but found 2的异常。</p><p><a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-expected-single" target="_blank" rel="noopener">https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-expected-single</a></p><h2 id="调试排查-expected-single-matching-bean-but-found-2-的错误"><a href="#调试排查-expected-single-matching-bean-but-found-2-的错误" class="headerlink" title="调试排查 expected single matching bean but found 2 的错误"></a>调试排查 expected single matching bean but found 2 的错误</h2><p>把工程导入IDE里，直接启动应用，抛出来的异常信息是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &apos;javax.sql.DataSource&apos; available: expected single matching bean but found 2: h2DataSource1,h2DataSource2</span><br><span class="line">at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1041) ~[spring-beans-4.3.9.RELEASE.jar:4.3.9.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:345) ~[spring-beans-4.3.9.RELEASE.jar:4.3.9.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:340) ~[spring-beans-4.3.9.RELEASE.jar:4.3.9.RELEASE]</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1090) ~[spring-context-4.3.9.RELEASE.jar:4.3.9.RELEASE]</span><br><span class="line">at org.springframework.boot.autoconfigure.jdbc.DataSourceInitializer.init(DataSourceInitializer.java:71) ~[spring-boot-autoconfigure-1.4.7.RELEASE.jar:1.4.7.RELEASE]</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_112]</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_112]</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_112]</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_112]</span><br><span class="line">at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement.invoke(InitDestroyAnnotationBeanPostProcessor.java:366) ~[spring-beans-4.3.9.RELEASE.jar:4.3.9.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:311) ~[spring-beans-4.3.9.RELEASE.jar:4.3.9.RELEASE]</span><br><span class="line">at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:134) ~[spring-beans-4.3.9.RELEASE.jar:4.3.9.RELEASE]</span><br><span class="line">... 30 common frames omitted</span><br></pre></td></tr></table></figure><p>很多人碰到这种错误时，就乱配置一通，找不到下手的办法。其实耐心排查下，是很简单的。</p><h2 id="抛出异常的原因"><a href="#抛出异常的原因" class="headerlink" title="抛出异常的原因"></a>抛出异常的原因</h2><p>异常信息写得很清楚了，在spring context里需要注入/获取到一个<code>DataSource</code>  bean，但是现在spring context里出现了两个，它们的名字是：h2DataSource1,h2DataSource2</p><p>那么有两个问题：</p><ol><li>应用是在哪里要注入/获取到一个<code>DataSource</code>  bean？</li><li>h2DataSource1,h2DataSource2 是在哪里定义的？</li></ol><h2 id="使用-Java-Exception-Breakpoint"><a href="#使用-Java-Exception-Breakpoint" class="headerlink" title="使用 Java Exception Breakpoint"></a>使用 Java Exception Breakpoint</h2><p>在IDE里，新建一个断点，类型是<code>Java Exception Breakpoint</code>（如果不清楚怎么添加，可以搜索对应IDE的使用文档），异常类是上面抛出来的<code>NoUniqueBeanDefinitionException</code>。</p><p>当断点停住时，查看栈，可以很清楚地找到是在<code>DataSourceInitializer.init() line: 71</code>这里要获取<code>DataSource</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Thread [main] (Suspended (exception NoUniqueBeanDefinitionException))</span><br><span class="line">owns: ConcurrentHashMap&lt;K,V&gt;  (id=49)</span><br><span class="line">owns: Object  (id=50)</span><br><span class="line">DefaultListableBeanFactory.resolveNamedBean(Class&lt;T&gt;, Object...) line: 1041</span><br><span class="line">DefaultListableBeanFactory.getBean(Class&lt;T&gt;, Object...) line: 345</span><br><span class="line">DefaultListableBeanFactory.getBean(Class&lt;T&gt;) line: 340</span><br><span class="line">AnnotationConfigEmbeddedWebApplicationContext(AbstractApplicationContext).getBean(Class&lt;T&gt;) line: 1090</span><br><span class="line">DataSourceInitializer.init() line: 71</span><br><span class="line">NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native method]</span><br><span class="line">NativeMethodAccessorImpl.invoke(Object, Object[]) line: 62</span><br><span class="line">DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 43</span><br><span class="line">Method.invoke(Object, Object...) line: 498</span><br><span class="line">InitDestroyAnnotationBeanPostProcessor$LifecycleElement.invoke(Object) line: 366</span><br><span class="line">InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(Object, String) line: 311</span><br><span class="line">CommonAnnotationBeanPostProcessor(InitDestroyAnnotationBeanPostProcessor).postProcessBeforeInitialization(Object, String) line: 134</span><br><span class="line">DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyBeanPostProcessorsBeforeInitialization(Object, String) line: 409</span><br><span class="line">DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).initializeBean(String, Object, RootBeanDefinition) line: 1620</span><br><span class="line">DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 555</span><br><span class="line">DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 483</span><br><span class="line">AbstractBeanFactory$1.getObject() line: 306</span><br><span class="line">DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory&lt;?&gt;) line: 230</span><br><span class="line">DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class&lt;T&gt;, Object[], boolean) line: 302</span><br><span class="line">DefaultListableBeanFactory(AbstractBeanFactory).getBean(String, Class&lt;T&gt;, Object...) line: 220</span><br><span class="line">DefaultListableBeanFactory.resolveNamedBean(Class&lt;T&gt;, Object...) line: 1018</span><br><span class="line">DefaultListableBeanFactory.getBean(Class&lt;T&gt;, Object...) line: 345</span><br><span class="line">DefaultListableBeanFactory.getBean(Class&lt;T&gt;) line: 340</span><br><span class="line">DataSourceInitializerPostProcessor.postProcessAfterInitialization(Object, String) line: 62</span><br><span class="line">DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyBeanPostProcessorsAfterInitialization(Object, String) line: 423</span><br><span class="line">DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).initializeBean(String, Object, RootBeanDefinition) line: 1633</span><br><span class="line">DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 555</span><br><span class="line">DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 483</span><br><span class="line">AbstractBeanFactory$1.getObject() line: 306</span><br><span class="line">DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory&lt;?&gt;) line: 230</span><br><span class="line">DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class&lt;T&gt;, Object[], boolean) line: 302</span><br><span class="line">DefaultListableBeanFactory(AbstractBeanFactory).getBean(String) line: 197</span><br><span class="line">DefaultListableBeanFactory.preInstantiateSingletons() line: 761</span><br><span class="line">AnnotationConfigEmbeddedWebApplicationContext(AbstractApplicationContext).finishBeanFactoryInitialization(ConfigurableListableBeanFactory) line: 867</span><br><span class="line">AnnotationConfigEmbeddedWebApplicationContext(AbstractApplicationContext).refresh() line: 543</span><br><span class="line">AnnotationConfigEmbeddedWebApplicationContext(EmbeddedWebApplicationContext).refresh() line: 122</span><br><span class="line">SpringApplication.refresh(ApplicationContext) line: 762</span><br><span class="line">SpringApplication.refreshContext(ConfigurableApplicationContext) line: 372</span><br><span class="line">SpringApplication.run(String...) line: 316</span><br><span class="line">SpringApplication.run(Object[], String[]) line: 1187</span><br><span class="line">SpringApplication.run(Object, String...) line: 1176</span><br><span class="line">DemoExpectedSingleApplication.main(String[]) line: 17</span><br></pre></td></tr></table></figure><h3 id="定位哪里要注入-使用DataSource"><a href="#定位哪里要注入-使用DataSource" class="headerlink" title="定位哪里要注入/使用DataSource"></a>定位哪里要注入/使用<code>DataSource</code></h3><p>要获取<code>DataSource</code>具体的代码是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.springframework.boot.autoconfigure.jdbc.DataSourceInitializer.init()</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.properties.isInitialize()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Initialization disabled (not running DDL scripts)"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.applicationContext.getBeanNamesForType(DataSource.class, <span class="keyword">false</span>,</span><br><span class="line"><span class="keyword">false</span>).length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.dataSource = <span class="keyword">this</span>.applicationContext.getBean(DataSource.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.dataSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">logger.debug(<span class="string">"No DataSource found so not initializing"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">runSchemaScripts();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>this.applicationContext.getBean(DataSource.class);</code> 要求spring context里只有一个<code>DataSource</code>的bean，但是应用里有两个，所以抛出了<code>NoUniqueBeanDefinitionException</code>。</p><h3 id="从BeanDefinition获取bean具体定义的代码"><a href="#从BeanDefinition获取bean具体定义的代码" class="headerlink" title="从BeanDefinition获取bean具体定义的代码"></a>从<code>BeanDefinition</code>获取bean具体定义的代码</h3><p>我们再来看 h2DataSource1,h2DataSource2 是在哪里定义的？</p><p>上面进程断在了<code>DefaultListableBeanFactory.resolveNamedBean(Class&lt;T&gt;, Object...)</code> 函数里的 <code>throw new NoUniqueBeanDefinitionException(requiredType, candidates.keySet());</code> 这一行。</p><p>那么我们在这里执行一下（如果不清楚，先搜索下IDE怎么在断点情况下执行代码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.getBeanDefinition(<span class="string">"h2DataSource1"</span>)</span><br></pre></td></tr></table></figure><p>返回的信息是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=demoExpectedSingleApplication; factoryMethodName=h2DataSource1; initMethodName=null; destroyMethodName=(inferred);</span><br><span class="line">defined in com.example.demo.expected.single.DemoExpectedSingleApplication</span><br></pre></td></tr></table></figure><p>可以很清楚地定位到<code>h2DataSource1</code>这个bean是在 <code>com.example.demo.expected.single.DemoExpectedSingleApplication</code>里定义的。</p><p>所以上面两个问题的答案是：</p><ol><li>是spring boot代码里的<code>DataSourceInitializer.init() line: 71</code>这里要获取<code>DataSource</code>，并且只允许有一个<code>DataSource</code>实例</li><li>h2DataSource1,h2DataSource2 是在<code>com.example.demo.expected.single.DemoExpectedSingleApplication</code>里定义的</li></ol><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>上面排查到的原因是：应用定义了两个<code>DataSource</code>实例，但是spring boot却要求只有一个。那么有两种办法来解决：</p><ol><li>使用<code>@Primary</code>来指定一个优先使用的<code>DataSource</code>，这样子spring boot里自动初始的代码会获取到<code>@Primary</code>的bean</li><li>把spring boot自动初始化<code>DataSource</code>相关的代码禁止掉，应用自己来控制所有的<code>DataSource</code>相关的bean</li></ol><p>禁止的办法有两种：</p><ol><li><p>在main函数上配置exclude</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication(exclude = &#123; DataSourceAutoConfiguration.class, DataSourceTransactionManagerAutoConfiguration.class &#125;)</span><br></pre></td></tr></table></figure></li><li><p>在application.properties里配置：</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration</span><br></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>排查spring初始化问题时，灵活使用Java Exception Breakpoint</li><li>从异常栈上，可以很容易找到哪里要注入/使用bean</li><li>从<code>BeanDefinition</code>可以找到bean是在哪里定义的（哪个Configuration类/xml）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;这个demo来说明怎么排查一个常见的spring expected single matching bean but fou
      
    
    </summary>
    
      <category term="技术" scheme="http://hengyunabc.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="java" scheme="http://hengyunabc.github.io/tags/java/"/>
    
      <category term="spring" scheme="http://hengyunabc.github.io/tags/spring/"/>
    
      <category term="spring-boot" scheme="http://hengyunabc.github.io/tags/spring-boot/"/>
    
  </entry>
  
</feed>
